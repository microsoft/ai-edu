Copyright © Microsoft Corporation. All rights reserved.
  适用于[License](https://github.com/Microsoft/ai-edu/blob/master/LICENSE.md)版权许可

# 针对时序数据的AI构建实战 - 基于“黄金点”游戏

**主要知识点：**

  - 黄金点游戏介绍

  - 服务端接口介绍

  - 游戏AI策略介绍

  - 动手实现多个游戏AI比赛

# 简介

本文以黄金点游戏为例介绍了一些简单的时序数据处理方法。文中首先介绍了黄金点游戏的由来以及规则；然后介绍了我们设计的黄金点游戏服务器的接口，玩家可以编写自己的AI程序通过这些接口与服务器通信，完成比赛；最后，我们介绍了几种常见的基于规则、基于识别、基于学习的策略，并最终实现了一个基于Q-Learning的AI程序。

# 背景

在之前的课程中，我们介绍了实际应用和生产中常见的三种接触人工智能的渠道：预构建 AI、自定义AI、自构建
AI；也介绍了这些渠道所提供的一些典型的在应用中集成人工智能的方式：集成人工智能的REST服务和集成本地模型。

在自定义AI和自构建AI的相关课程中，我们介绍了一些扩展人工智能模型的过程（如自定义视觉服务和扩展MNIST数据集），也介绍了人工智能模型的生命周期（如基于MNIST数据集的模型和其扩展模型的训练过程）。不过这些内容都偏向于集成和调用，至今我们还没有接触过一些更深层的、与AI模型的构建相关的内容。

AI的构建和应用与数据是密不可分的。我们的现实生活中有这样一种非常常见的数据类型，那就是时序数据。时序数据是一系列按照时间顺序排布的数据。时序数据通常是由固定的时间间隔（比如一秒或一分钟）分隔的。诸如天气数据、股票数据等数据都是时序数据。产生时序数据的系统往往非常复杂，导致产生的时序数据几乎是随机的，并不表现出明显的规律和趋势，这也使得对时序数据的预测变得非常困难。

在各种各样的能产生时序数据的系统里，“黄金点”游戏非常令人感兴趣。在“黄金点”游戏中，各个玩家提交的数据将产生一个“黄金点”的时间序列。并且，该游戏的规则非常明确和直观。尝试用AI的手段来获取“黄金点”游戏的胜利，是一种很适合我们学习AI知识和技术的方式。

本文将基于“黄金点”游戏，介绍构建AI模型相关的一些细节。

# “黄金点”游戏介绍

笔者最早接触“黄金点”游戏是通过邹欣老师的软件工程教材《构建之法》及他的博客“[创新的时机 –
黄金点游戏](https://www.cnblogs.com/xinz/archive/2011/08/08/2130505.html)”，里面对游戏是这样介绍的：

>*N个同学（N通常大于10），每人写一个0~100之间的有理数
(不包括0或100)，交给裁判，裁判算出所有数字的平均值，然后乘以0.618（所谓黄金分割常数），得到G值。提交的数字最靠近G（取绝对值）的同学得到N分，离G最远的同学得到－2分，其他同学得0分。*

同时，邹老师的著作中还提到了这个游戏的来源：

>*这个游戏是经济学家Richar
Thaler构思的，1997年伦敦金融时报进行了一次公开竞猜活动，他们用的系数是2/3，所有人的平均值是18.91。2006年，我是在清华软件学院的一个培训班上第一次玩这个游戏。后来这个游戏成了我演讲和讲课的固定节目，在不少大学的计算机系都玩过。*

如果让你参与这个游戏，你会写下哪个数字呢？

通常大家会想，如果所有人随机出数，那么所有人的平均值将是50，50\*0.618=31，那是不是出31比较合适呢。但是很多人也会考虑到这一点，如果大家都出了31，那是不是出31\*0.618=19更合适呢。

如此循环下去你就会发现，这个数越来越小，那是不是出个很小的数胜率更大呢？也不尽然，很有可能其它参与者并没有想到那么深，你如果出的数过于超前也得不到分。

经过邹老师多次的观察，第一轮获胜的数字离17不远，另外，如果继续玩下去，10轮、20轮，从总体趋势来看，数值会逼近0，但是偶尔也会有小的反弹，然后又继续逼近0。

![](./media/image1.png)

上图是邹老师在清华大学2008秋季学期连续12次黄金点游戏的记录。

在只有第一名得分、最后一名扣分的规则下，大家更愿意出小一些的数而不是去向上扰动黄金点的值。于是100轮甚至更多轮比赛时，往往变成了大家出了带一堆0的小数，然后比较哪个小数更接近黄金点。

基于此，我们对游戏规则进行了调整，允许每个玩家出两个数，鼓励玩家对黄金点进行扰动。可以一个数出的很大，来保证自己的另一个数比较接近黄金点，这样在失分的情况下也有机会同时得分；也可以两个数都去尝试猜中黄金点，双保险。

整理后新的规则如下：

  - 有N个玩家参与游戏

  - 每个玩家可以自由选择两个0-100之间的两个有理数（不包括0和100）进行提交

  - 所有2\*N个数提交后，计算所有数的平均值，然后将平均值乘以0.618得到这一轮的黄金点

  - 分别计算所有玩家提交的两个数字与黄金点的算术差的绝对值，值最小者得分，值最大者扣分，其它玩家不得分

具体计分规则如下：

  - N个玩家参与游戏时，离黄金点最近的玩家得N分，最远的扣2分，其它玩家不得分

  - 如果多个玩家在一轮内同时离黄金点最近，每个玩家得N分

  - 如果多个玩家在一轮内同时离黄金点最远，每个玩家扣2分

  - 如果一个玩家在一轮提交的两个数相同并得分或扣分时，只计一次分

  - 如果N=1，即只有一个玩家参与游戏时，不记分

  - 固定轮数（100轮或更多）比赛后，累加玩家每轮的得分得到总成绩，得分最高者为最终胜出玩家

按照新规则，我们组织一批学生写AI进行了两场比赛，第一场比赛200轮

| ![](./media/image2.png) | 
|:--:| 
| 第一场比赛 – 全部200轮黄金点走势图 |

| ![](./media/image3.png)|
|:--:| 
| 第一场比赛 – 最后100轮黄金点走势图 |

从第一场比赛可以看出黄金点在刚开始的几轮急速下降，但下降到4~5之间时，一直在细微的波动，说明大家都比较谨慎，没有明显的扰局现象。另外从玩家得分上看，由于大家都比较保守的去预测黄金点，所以得分相对均匀。

随后我们公布了结果，并让大家改进AI，又组织进行了400轮的比赛

| ![](./media/image4.png) |
|:--:| 
| 第二场比赛 – 全部400轮黄金点走势图 |

| ![](./media/image5.png) |
|:--:| 
| 第二场比赛 – 最后100轮黄金点走势图 |

从第二场比赛可以看出明显第二场要比第一场激烈的多。一个有意思的现象是，在刚开始几轮急速下降后，走势并没有趋向于平稳，而是在有规律的跳动，明显是有玩家在有策略的扰动黄金点。

在事后我们对最终胜出的玩家进行了采访，他们提到在分析第一场的数据时，发现了一个有趣的现象：故意提交大数字的
玩家并没能扰乱黄金点的收敛趋势，反而被扣了很多分。但是他们转念一想，如果大家的结果都在上一轮的黄金点附近波动，那么可以用一个大数来制造扰动，然后根据自己的大数做出相应的调整，给出另一个输出（在比赛中，如果选择
99 作为大数，通常下一轮的 G 会增加
1.1）。

他们迅速实现了想法，并根据第一场的历史数据调整了预测参数。第二场比赛时，黄金点并没有平稳收敛，而是随着他们的扰动策略不断波动，而他们也顺理成章的取得了大把的得分。第二场同样有玩家选择了扰动策略，但却因为对扰动时机、扰动后的预测范围等细节把控不到位，而与胜利失之交臂，可见对细节的掌控也是稳定发挥的基础。

# 服务端接口

回到本文的主题上来，我们期望大家可以使用时序的数据来构建AI模型，并且预测时序数据下一步可能出现的值。

为了让大家的AI可以顺利地进行游戏，并验证我们对策略和AI的一些实现，我们需要一些基础设施来帮助我们完成一些工作。这些工作包括游戏回合的控制、参与者之间的数据同步、游戏数据的储存等功能。

为了简化这些基础工作，以便大家可以更好地集中于AI本身的设计和实现，我们搭建了一个服务器提供了一些基本的接口。使用这些接口，AI可以做到简单的调用REST
API接口实现游戏回合时间同步、获取历史数据、提交预测数据等功能。

下图描述了服务器如何驱动游戏一回合接着一回合的运转，同时指出了AI或客户端应何时与服务器交互。

![](./media/image6.png)

当AI或客户端进入游戏后，应立即向服务器请求获取当前回合的状态，此时可以知道服务器上正在进行的游戏回合的编号，以及本回合还有多长时间结束。AI或客户端可以按照返回的回合编号向服务器提交预测值，并且可以根据本回合剩余时间，设定一个定时器，在下一回合开始时，再次执行获取回合状态的接口，来取得下一回合的状态。这样依次轮转下去，AI或客户端就可以一直参与在游戏中。
同时，AI或客户端还可以在每回合开始时，调用获取历史数据的接口，来得到前几回合的比赛数据。这样可以知道自己在上一回合是否得分胜出，并可以根据历史数据来指导当前回合的预测值。

## 接口概述

服务器地址：https://goldennumber.azurewebsites.net

所有请求需要的参数都拼装在URL中，并且需要对值进行URL编码。

所有请求的响应报文内容都是JSON格式

如果服务器响应代码不是2\*\*或3\*\*，表示该次请求失败。

**失败的响应报文至少包含下面一个属性：**

属性名 | 数据类型 | 备注
-|-|-
message | String | 出错的具体信息

## 新建玩家

请求方式：GET

路径：/api/NewUser

客户端使用该接口可以新建一个玩家。

请求需要用到的参数：

参数名 | 数据类型 | 是否必需 | 备注
-|-|-|-
nickName | String | 可选 | 用户昵称<br>如果长度超过20，将被截断<br>建议设置昵称，昵称相对于标识有更好的辨识度

响应报文内容中的属性：

属性名 | 数据类型 | 备注
-|-|-
userId | String | 用户标识，格式为Guid格式
nickName | String | 用户昵称

## 设置用户昵称

请求方式：POST

路径：/api/NickName

使用该接口可以用来修改用户的昵称，昵称相对于标识来说，有更佳的辩识度。

请求需要用到的参数：

参数名 | 数据类型 | 是否必需 | 备注
-|-|-|-
uid | String | 必需 | 用户标识
nickname | String | 必需 | 用户昵称，长度大于20会被截断

## 获取新游戏房间

请求方式：GET

路径：/api/NewRoom

使用该接口创建一个新的游戏房间并获取对应的编号。

请求需要用到的参数：

参数名 | 数据类型 | 是否必需 | 备注
-|-|-|-
uid | string | 必需 | 房间创建者的标识
numbers | Int | 可选 | 设置游戏支持的每个玩家可以提交的预测值的个数<br>默认是1，表示每个玩家可以提交一个数
duration | Int | 可选 | 设置游戏中每回合的间隔时间<br>默认值是60秒，取值范围在10~200之间
userCount | int | 可选 | 设置游戏中允许的最大玩家数<br>默认值是0，表示没有限制<br>有玩家数量限制的房间，当所有玩家都提交预测值后，会立即计算本回合结果，并开始下一轮<br>有玩家数量限制的房间，支持返回固定列数的格式化好的历史数据，未提交预测值的用0代替，但不参与计算<br>注意：这里的玩家数量限制是针对房间的，不是针对一个回合，只要玩家在房间内任一回合提交过预测值，则认为该玩家始终在房间内
roundCount | int | 可选 | 设置比赛总回合数<br>默认值是0，表示没有限制<br>如果某一回合没有玩家提交数据，认为该回合无效，不计在回合数内<br>如果有效回合数达到设置的总回合数，游戏结束，不再允许提交数据
manuallyStart | Int | 可选 | 是否手动开始游戏<br>默认值0，表示创建完房间后，游戏自动开始<br>如果是1，表示需要由创建者手动开始游戏

响应报文内容中的属性：

属性名 | 数据类型 | 备注
-|-|-
roomId | Int | 游戏房间编号

## 开始游戏

请求方式：GET

路径：/api/StartGame

如果创建游戏时设置的是手动开始，那么游戏创建者可以调用该接口开始游戏。

请求需要用到的参数：

参数名 | 数据类型 | 是否必需 | 备注
-|-|-|-
uid | string | 必需 | 房间创建者的标识
roomid | int | 可选 | 房间编号<br>如果未设置，默认为0号游戏房间

## 获取游戏状态

请求方式：GET

路径：/api/State

客户端使用该接口可以获取当前房间内的游戏状态，可以根据当前游戏支持提交的预测值的个数进行提交。同时还可以知道当前回合什么时间结束，推算出什么时候可以取得本回合的比赛数据以及获取下一轮比赛的相关信息。

请求需要用到的参数：

参数名 | 数据类型 | 是否必需 | 备注
-|-|-|-
uid | String | 可选 | 用户标识
roomid | Int | 可选 | 房间编号<br>如果此参数为空，默认0号房间

响应报文内容中的属性：

属性名 | 数据类型 | 备注
-|-|-
userId | String | 用户标识
nickName | String | 用户昵称
roomId | Int | 房间编号
numbers | Int | 当前房间内的游戏支持提交的预测值的个数，1或2
roundId | string | 当前房间内正在进行的游戏回合标识
leftTime | int | 当前游戏回合还有多少秒截止提交
roundEndTime | datetime | 当前回合截止提交的UTC时间
state | int | 当前游戏状态<br>0代表进行中<br>1代表未开始，需要房间创建者手动开始<br> 2代表已结束，不允许再向房间内提交数据
hasSubmitted | bool | 当前用户本回合是否已提交预测值
isRoomCreator | bool | 当前用户是否是当前房间的创建者。<br>如果房间在创建时没有指定自动开始，需要创建者手动开始游戏
maxUserCount | int | 创建房间时设定的玩家数<br>0表示没有限制<br>最大不能超过200<br>设置人数上限的房间中，在获取格式化的历史数据时，会将未加入游戏的玩家的预测值用0来填补，保证每回合取到的数据都是固定列数的规整数据<br>同时，设置人数上限的房间中，如果所有玩家都已提交，则立该结束当前回合，并开始下一回合
currentUserCount | int | 当前房间内提交过预测值的玩家数量
totalRoundCount | int | 创建房间时设定的该房间可以进行的有效回合数
finishedRoundCount | int | 当前房间内已经进行的有效回合数<br>玩家提交过预测值的回合认为是有效回合，否则忽略该回合，继续等待玩家提交

## 提交预测值

请求方式：POST

路径：/api/Submit

客户端使用该接口可以向服务器提交预测值。每回合只允许提交一次，提交成功后不可修改。

如果当前房间设置了玩家人数上限，则当所有玩家提交了预测值后，立即计算本回合结果，并开始下一回合。

请求需要用到的参数：

参数名 | 数据类型 | 是否必需 | 备注
-|-|-|-
rid | String | 必需 | 要提交预测值的回合标识，需要是GUID的格式
uid | string | 必需 | 提交预测值的用户标识
n1 | Double | 必需 | 预测值，必须是0到100之间的有理数，不包括0和100
n2 | Double | 可选 | 第二个预测值，如果当前游戏是支持两个数的游戏，此参数也为必需项；如果当前游戏仅支持一个数，此参数将被忽略

## 获取历史数据

请求方式：GET

路径：/api/History

使用该接口可以获取当前房间内的历史数据，包括每回合的黄金点、每个玩家的预测值、得分等信息。

没有指定任何参数时，返回0号房间内最新的10回合的历史。

请求需要用到的参数：

参数名 | 数据类型 | 是否必需 | 备注
-|-|-|-
roomid | String | 可选 | 房间编号<br>如果该参数为空，默认0号房间
startrid | String | 可选 | 开始查询的游戏回合标识<br>如果该参数为空，默认为当前正在进行的回合
count | Int | 可选 | 指定从startrid开始返回多少回合的历史，不包括startrid回合<br>如果没有指定该参数，默认为10，最大不超过100
direction | Int | 可选 | 查询的方向<br>默认值是0，表示从startrid查询旧的历史数据<br>另一个值是1，表示从startrid查询更新数据

响应报文内容中的属性：

属性名 | 数据类型 | 备注
-|-|-
rounds | Array | 查询到的回合的数组，数组的每个元素包含以下属性：<br>roundId, time, goldenNumber, userNumbers
&nbsp;&nbsp;&nbsp;&nbsp;roundId | String | 回合标识
&nbsp;&nbsp;&nbsp;&nbsp;index | int | 该回合在当前房间中的索引编号
&nbsp;&nbsp;&nbsp;&nbsp;time | String | 该回合的截止时间，UTC
&nbsp;&nbsp;&nbsp;&nbsp;goldenNumber | Double | 该回合的黄金点
&nbsp;&nbsp;&nbsp;&nbsp;userNumbers | Array | 该回合所有玩家提交的数的数组，数组的每个元素所含以下属性：<br>userId, masterNumber, slaveNumber, score
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;userId | String | 用户标识
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;masterNumber | double | 用户提交的第一个预测值
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;slaveNumber | double | 用户提交的第二个预测值，仅当当前游戏支持提交两个数的时候有效
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;score | Int | 用户在当前回合的得分
nickNames | object | 用户编号和用户昵称的字典<br>用户编号是key，用户昵称是value

## 获取格式化的历史数据

请求方式：GET

路径：/api/FormattedHistory

使用该接口可以获取当前房间内已完成的所有回合的历史数据。

请求需要用到的参数：

参数名 | 数据类型 | 是否必需 | 备注
-|-|-|-
roomid | int | 可选 | 房间编号<br>如果未设置，默认为0号游戏房间

响应报文内容中的属性：

属性名 | 数据类型 | 备注
-|-|-
formattedData | string | 格式化的所有回合历史数据，该字符串是多行文本结构<br>格式举例：<br>2	5<br>18.07	30	30	17	40<br>24.87	18.08	18.08	99.9	25<br>第一行两个数表示下面有两行数据，每行数据有5个值。后面每行代表一轮比赛的数据，最后一行是最新一轮的数据。行中第一个数据是该轮的黄金点值，后面依次是是每个玩家提交的1个（或2个）预测值，数据之间以制表符分隔。如果某个值为0，表示该玩家在该轮超时未提交数据或提交数据失败
userList | array | 用户列表，数组中的每个元素包含以下属性：<br>userId, nickName, score, index
&nbsp;&nbsp;&nbsp;&nbsp;userId | string | 用户标识
&nbsp;&nbsp;&nbsp;&nbsp;nickName | string | 用户昵称
&nbsp;&nbsp;&nbsp;&nbsp;score | int | 得分
&nbsp;&nbsp;&nbsp;&nbsp;index | int | 该用户在当前房间内的索引号

## 查询得分

请求方式：GET

路径：/api/Score

使用该接口可以查询游戏房间内所有玩家的得分情况。

请求需要用到的参数：

参数名 | 数据类型 | 是否必需 | 备注
-|-|-|-
roomid | int | 可选 | 房间编号<br>如果未设置，默认为0号游戏房间

响应报文内容中的属性：

属性名 | 数据类型 | 备注
-|-|-
scoreList | array | 数组中的每个元素包含以下属性：<br>userId, nickName, score, index
&nbsp;&nbsp;&nbsp;&nbsp;userId | string | 用户标识
&nbsp;&nbsp;&nbsp;&nbsp;nickName | string | 用户昵称
&nbsp;&nbsp;&nbsp;&nbsp;score | int | 得分
&nbsp;&nbsp;&nbsp;&nbsp;index | int | 该用户在当前房间内的索引号


# 游戏策略

## 基于规则的策略

当我们思索游戏的制胜策略时，我们想到或许一些简单的策略就能取得出乎意料的效果。比如人在思索游戏对策的时候，经常想到的一种对策就是基于规则的，其表现为一系列“当对方……我就……”形式的条件和计划。当游戏的对手确实执行了我们预测中的操作时，我们从预先定义的计划里找到对应的手段并执行。这种基于规则的策略往往要求我们先尽可能地预测对手的行为，并做出针对性的压制计划。

典型的基于规则的策略有：重复上一回合的黄金点、上一回合黄金点乘以0.618、取最近十轮中黄金点的均值、使用固定值如42、生成（0，100）区间内的随机数等等。

## 基于识别的策略

基于规则的策略能达到的成就或许有限，因为我们处于一个复杂且多变的游戏环境，我们可能很难有效地制定一些应对性的规则。除了简单规则之外，我们还可以尝试的一种手段是基于识别的策略，即我们可以先尝试识别对手使用的是怎样的策略，然后再预测其在下一轮比赛中可能采取的行动，然后再做针对性的应对。比如，如果我们识别了对手采取的是“重复上一轮黄金点”这一基于规则的策略，我们就能有效地进行应对（如提交任意比上轮黄金点小的数）。我们可以看出，这种策略比起基于规则的策略有着更为超前的视野。然而，考虑到游戏本身的复杂性，我们能有效识别的敌方策略，可能会很有限。

## 基于学习的策略

除了上述的策略，我们还可以采用基于学习的策略。观察过几组游戏的历史记录后，我们注意到这些历史记录中似乎是存在一定规律的，但是其潜在的规律难以用简单的规则或手工组织的程序来捕捉。对此，我们可以尝试通过AI和机器学习的方式来完成这一任务。

AI的领域发展得很好，相关技术也比较多。要用于我们“黄金点”的游戏预测，我们可以通过这样一些形式来应用AI的技术：

  - 先将将黄金点数据用特定的编码方式编码，如将黄金点的趋势转换为“上升/下降X%”的形式，其中X可以是几个固定的值如10、20、50等。这样我们的预测问题就变成了分类问题，我们可以通过逻辑回归、决策树、支持向量机等方法，基于每个黄金点和它之前一些回合的历史数据来建立我们的分类模型，并服务于对未来回合的预测。

  - 除了总是专注于下一次的成功，我们还可以通过拟合黄金点概率分布的方式，争取在所有回合结束后，得到最高的总分。

  - 直接使用时序数据预测的方式，对黄金点进行预测。比如通过神经网络基于历史数据建立模型，并直接输出要提交的结果。

## 其他策略

当游戏处于需要提交两个数的模式时，让两个数相互配合就成了一种很自然的游戏方式。

或者我们可以在一定回合内进行搅局（如通过随机数的方式），扰乱他人的游戏，并在剩余的回合里尽可能争取胜利。

并且我们还能采取混合多种策略的形式来进行游戏。比如我们可以用统计或者机器学习方法对其他玩家的数据做拟合以识别他们的策略，以及通过固定的规则来控制、推动我们的搅局或正常预测的进行等等。

> **注意**
>
> 我们可以看出，游戏的参与者本身也是游戏的重要组成部分。参与者在某一轮中提交的数字，极有可能动态地影响到下一轮的游戏结果。作为竞争者参与游戏，和只使用历史数据进行重演和推导，在一定的游戏规模下，这将是两种不同的工作。

# 主体流程分析和实现

从上述的服务器接口描述和定义，我们可以看出，一个最基本的黄金点游戏程序应该具有哪些功能。

要顺利地进行游戏，最核心的两个功能，就是通过服务器提供的RESTful API进行**获取当前回合状态**（`GET /api/state`）和**提交数字**（`POST /api/submit`）。这两个核心操作中，由于提交数字时必须知道当前的游戏设置（如需要提交一个数还是两个数），以及当前的回合ID，所以在提交之前，正确地获取当前回合的状态是必要的。否则提交会失败。有了这两个功能，我们前面列举的一些最简单的游戏策略就可以被实现了，比如提交随机数，提交固定的数等。

当然，上面提到的最简单的两个策略可能不会表现得很好。为此，我们还需要调用**获取历史数据**接口（`GET /api/history`）。这一接口为我们实现诸如重复上一轮的黄金点、计算以前数轮黄金点的均值、推测他人策略、学习历史数据这样的策略提供了可能。

对于上述三个主要的接口，上文已经对作为其输入的HTTP请求，和服务器输出的数据结构的格式做了一番说明。这里我们对主体流程和相关的要点做一下整理：

1. 第一次获取当前回合状态，初始化客户端环境。包括玩家ID、回合倒计时等；
2. 尝试在回合倒计时结束前，向服务器提交数据。
    - 提交时必须声明提交针对的回合，已经过去的、不合法的回合会导致提交失败。
3. 倒计时结束后，获取新一回合——也即当前回合——的状态。
    - 由于时间同步可能不稳定，只有观察到回合ID较之前改变了，新回合才算开始。
4. 回到第2步。

伪代码如下：
```c
// 任一房间号。省略的话，默认是0号房间。
roomId=42

// 初始化。
user = NewUser(nickName="foo")
userId = user.userId // 整个循环中，只使用一个用户ID，以正确统计得分。

// 游戏主循环。
while true:   

    // 获取当前游戏的状态，包括当前回合的标识号，回合结束的剩余时间等
    state = GetState(uid=userId, roomId=roomId) 

    // 获取当前房间的历史记录。默认是从当前回合开始追溯。
    history = GetHistory(roomId) 

    // 尝试在当前回合结束前，向服务器提交数据。
    while DateTime.now < state.roundEndTime:
        if HaveNotSubmittedForRound(state.roundId):

            // 核心：策略实现。
            num = Calculate(history) 

            Submit(num, uid=userId, rid=roundId) // 提交数据必须指定提交者ID和目标回合ID。

    while true:
        nextState = GetState(uid=userId, roomId=roomId) // 使用当前用户ID，避免分配新ID。

        // 直到确认新回合开始了，才更新客户端状态。
        if nextState.roundId != state.roundId: 
            state = nextState
            break
```
