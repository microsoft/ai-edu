## 15.1 木头与软件测试的故事

转眼之间，木头已来到自己职业生涯的第8个年头，本月初有一位新同事小陈入职，木头带领他一起完成了一次线上bug的排查。借由这次机会，小陈很快地熟悉了项目中的相关feature，定位到了代码中的问题，并在木头的帮助下得出了解决方案：需要改一行代码，然后加两行日志收集的代码方面进行修复情况跟进。

### 15.1.1 一行代码引起的“惨案”

拿定主意，新人小陈熟练的打开IDE，写好并提交了代码，就找到木头，兴致勃勃地讲述了想法，打算一气呵成地完成代码签入、热修复（hotfix）、部署和发布，完成自己职业生涯的第一个“代码产品化”里程碑。木头见他热情可嘉，回想起了自己初入职场的青葱岁月，也没有直接泼冷水，打趣说道：

“好啊，不过你这个里程碑肯定早晚会拿到，你先别急着合入代码修改，先针对这段改动丰富一下单元测试，然后最好自己也多测几轮，这样再上线，比较稳妥。这个feature虽然是新feature，不过生产环境目标用户数量也有好几万了。”

“这...需要吗？一共就一行代码改动，加了个if判断，都是局部变量，不可能出问题啊。”小陈一脸狐疑的说道。他心想自己以往LeetCode战无不胜，写代码经常是一把过，这次就这么简单的改动的话，完全可以省去测试流程。

“哦，可是这里还加了日志输出，原来是没有这个调用的。”木头一边看着小陈的改动，一边说道。

```java
    private void interceptRedirect(String redirectUrl){
        ...
        traceLogger.infoWithArgs(String.format("Redirect URL: %s", redirectUrl));
        ...
    }
```

```java
// 以下是示例infoWithArgs的底层实现，并没有在本次修改中被小陈修改。
public class TraceLogger {
    ...
    public void infoWithArgs(String message, Object... args){
        ...
        info(String.format(message, args));
        ...
    }
    ...
}
```

“对对，不过这个能出什么问题吗，日志模块的接口到处都在调用，我这里就是把变量的值打印出来而已。而且这个方法貌似已经有一个单元测试在覆盖了，你看这里。”

```java
    public void testInterceptRedirect_NoException(String redirectUrl) {
        ...
        interceptor.interceptRedirect("https://www.bing.com/search?q=software+testing");
        ...
    }
```

聊到此处，木头直觉事情没有那么简单，“你调用日志的时候，没有传入参数，却调用了infoWithArgs，嗯，这样会有问题吗？”。

“我从上面直接复制粘贴过来的，应该没问题吧？单元测试是通过的。”

两人一起研究起了一下这段代码，并对现有的单元测试进行了扩展，提供了一些新的数据用例，实战了一下结对编程。没想到，两人很快发现在入参URL为某些特例（包含%a、%b或%c）的时候，字符串格式化语句会出现异常 `MissingFormatArgumentException` 报错，导致整个业务流中断。而这个所谓的特例，在这个业务场景中和代码逻辑中频次很高，可能会导致线上数千用户的体验中断。

```java
    @Test
    public void testInterceptRedirect_NoException(String redirectUrl) {
        ...
        interceptor.interceptRedirect("https://www.bing.com/search?q=software+testing");
        // 新增的用例会在原有代码上触发 `MissingFormatArgumentException` 异常
        interceptor.interceptRedirect("https://www.bing.com/search?q=%e5%be%ae%e8%bd%af%e4%b8%ad%e5%9b%bd");
        ...
    }
```

小陈惊出一身冷汗，自己心心念念的职业里程碑，差点演变成大型翻车现场；本来是打算修复一个线上问题，没想到差点制造出新问题。这时的他再看木头，不由觉得木头周身有一圈佛光，是上天派来拯救他的。“看来一行代码改动也要仔细研究，而测试是很好的代码问题的检验手段，需要多下功夫研究研究。”小陈顿了顿，然后激动地说：“软件bug的代价太大，宁可错杀，不可放过。”小陈又燃了起来，不过这次却让木头很是欣慰，听的频频点头。

“哈哈，你讲的挺逗，确实如此，bug能咱们自己发现修掉，就不要让客户帮咱们体验。从某种程度上来说，编程是对逻辑复杂性的管理。咱们的项目代码行数是百万级别的，逻辑复杂，情境和用例非常多，每一处修改都有可能牵一发而动全身。全面的测试可以帮助我们在更早的阶段评估代码修改的影响。”

木头接着说：“其实你不用后怕，咱们的代码合入之后，还会经过层层检测。代码合入主分支之后还会经过bvt测试、更全面的集成测试，热修复上线之前还会经过验收测试、回归测试以及压力测试，再部署到测试环境，进行内部的自测。之后都没问题，才可能发布到预生产环境、生产环境。所以你这个问题，大概率能够在上到预生产之前被拦截下来。我估计集成测试都过不了，哈哈。”

小陈挠头附和打个哈哈，心想，这些你不早说，原来还有这么一大堆测试。

又聊了几句，两人看时间不早了，就由小陈着手把代码修复完整后提交了，等待其他同事帮忙评审，就先下班了。

“还有一条规则，周五下午坚决不发版。下周见！”木头大手一挥，消失在大楼转角。

### 15.1.2 小陈的反思

今天发生的事情对小陈触动很大，回家后他依然在思考，为什么自己当时写代码时没有想到这个特例（corner case）？木头说的“全面的测试”，又如何理解其具体含义？一方面，他今天只接触了单元测试，而木头还提到了其他很多种类的测试。另一方面，测试团队似乎很重要，可以帮忙发现很多问题，而自己作为开发人员、代码修改的第一作者，和“全面的测试”之间的关系是什么？是否软件质量要依赖于测试团队的工作？

最终，如果有了“全面的测试”，是不是软件质量就可以高枕无忧了？

带着这样一个又一个问题，小陈查了查资料，看到一句“测试是为发现错误而执行程序的过程”，还没来得及梳理出脉络，就感觉困意袭来，于是洗漱睡觉，结束了充实的一天。
