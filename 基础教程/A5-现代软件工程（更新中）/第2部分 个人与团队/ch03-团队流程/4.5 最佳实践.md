



我们以做一个计算器软件为例，说明

<img src="Images/Slide12.JPG"/>


### Make it Work - 能运行

首先，我们做一个比较粗糙的原型。

从功能上看：
1. 提供基本的输入功能，包括数字和运算符，但是只有“1,2,+,=”四个按键；
2. 提供输出显示功能，能把输入显示在屏幕上，但是目前阶段只能显示“1,2,+,=”四种字符；
3. 输入“1+2”后，按“=”键，在屏幕上可以显示结果，但是结果可能是“2”，而不是预期的“3”。

从界面上看：
1. 几个按钮的大小和位置不整齐，但不影响使用；
2. 显示框歪歪扭扭，但还能看清楚数字；
3. 外边框也不是很美观，用了很不协调的红色。

如图13 左子图所示。
<img src="Images/Slide13.JPG"/>

### Make it Correct - 结果对

1. 原型可以工作了，但是结果并不正确，所以需要 debug 来排查错误。
2. 同时，顺手把四个按钮的大小和位置调整得好看一些，再把边框改成搭配的黄色，显得稍微懂一些美学，别给咱们程序员丢脸。
3. 再次输入“1+2=”后，可以得到正确的结果“3”了。
4. 能显示更多种类的字符了，但是显示区长度还比较短，只能有 6 个字符。

如图13 右子图所示。

### Make it Fast - 算得快

结果虽然正确了，但是发现再输入“=”后，要等 3 秒钟以上才得到结果。这是怎么回事呢？

经过代码检查和 debug 发现：

1. 输入的数字，首先被变成了字符串，在接收到“=”号输入后，从屏幕显示缓冲区把字符串取出来，解析成两组数字“1,2”和“+”号，再进行实际的数学计算。这个设计糟糕透了。
2. 不知道哪一位程序员脑洞大开，把本来可以在本地进行的计算设计成调用网络服务，还号称是可扩展的 B/S 模式，将来可以调用任何新实现的数学运算。
3. 最气人的是，为了显示美观，有人引入了一个巨大的第三方库，而且对该库没有进行任何安全性检查，不知道它都跑了哪些逻辑。
4. 最难以发现的是，每次运算都会触发一次日志记录操作，由于开发过程中的自动测试用例也写日志，导致日志文件变得越来越大，打开、寻址、写入、关闭文件的操作变得很慢。

当然，以上这些都是在原型阶段发现的问题，还有可以纠正的机会。

### Make it Rich - 功能全

在经过需求评审和设计评审后，这个项目进入了正式的实现阶段。已知的功能有：
1. 支持按键数字从0-9；
2. 操作符支持“加减乘除”；
3. 显示区可以显示 10 个字符了，在超过 10 个字符时，用户输入时会有“滴滴”的报警声；
4. 由于还没有收到 Designer 的设计图，界面上还是有些歪歪扭扭的，而且字体的选择也有些问题，上下边界没有对齐。

如图 14 所示。所以虽然功能都已经实现了，还是没法交给最终用户使用。

<img src="Images/Slide14.JPG"/>

### Make it Live - 给用户

终于收到 Designer 的设计图了：

1. 0-9 十个数字的排列顺序让程序员们讨论了半天，为什么 “789” 在上面？找到了一个实际的计算器一看，确实是这样排列的；
2. “加减乘除”四个按钮的顺序也是颠倒过来的，并且与左侧数字去拉开了距离；
3. 字体统一使用等宽形式，上下边界也对齐了；
4. 按键区与显示区的中线对齐，上下左右的边界间距也都合理；
5. 增加了“删除”按钮，可以随时修改输入错误，而在此之前，程序员们测试时都是一通乱按，无所谓对错；
6. 界面边框不再是七扭八歪的了，很规矩。

如图14 右子图所示。这样修改之后，再次经过回归测试，功能性能都没问题，这个简单的应用终于可以发布给用户使用了。


### 垂直切片

如图 15 所示

<img src="Images/Slide15.JPG"/>


|技术栈|第一期|第二期|第三期|
|--|--|--|--|
|界面显示|能看明白|应有尽有|美观合理|
|字符数量|五个字符|十个字符|任意多个，可以横向滚动|
|辅助功能|等号|等号、删除|等号、删除、M+、M-、MC|
|计算功能|加|加、减|加、减、乘、除|
|数字按键|123|123456789|1234567890|

我们用计算器应用这个简单的例子来做说明

技术栈一共有五层

- 界面显示

    即最终用户可以看到的界面，包括各个界面元素的颜色、尺寸、线宽、间距、位置等等，这些都需要 Designer 的精心设计。
    举个例子，0~9 这 10 个按键在界面上应该如何排列？想当年贝尔实验室设计电话按键时，其实排在第一位的按键布局是下面这个：
    ```
    1 2 3 4 5
    6 7 8 9 0
    ```
    但是太宽了，所以最终设计成这样：
    ```
    1 2 3
    4 5 6
    7 8 9
      0
    ```
    原因是人们在公共电话亭站着打电话时，“1 2 3”距离人的视线较近。但是计算器的键盘设计却都是相反的：
    ```
    7 8 9
    4 5 6
    1 2 3
      0
    ```
    原因相同：人们坐着按计算器时，“1 2 3”距离人的视线较近。

- 字符数量

    即可以在输出区域显示的字符数量，这涉及到输出缓冲区的设计，及界面的设计。缓冲区的大小不是什么问题，因为计算机的内存足够大。但是如果界面输出框宽度为 8 厘米，字号为 24pt 时只能有 10 个左右的字符可以显示。

- 辅助功能

    包括等号键、回退删除键、存储加键、存储减键，存储清空键。

- 计算功能

    包括“加、减、乘、除”四种操作。当然对于复杂的计算器来说，还会有指数、对数、乘方、开方等操作符。

- 数字按键

    从 0 到 9 的按键输入，属于输入功能界定，并非指的这 10 个按键如何在界面上呈现。

#### 第一期

如图 15 的子图 1 所示

- 数字按键只支持“1,2,3”；
- 计算功能只支持“加法”；
- 辅助功能只有“等号”；
- 显示字符数量最多 5 个；
- 界面显示以“能（让程序员）看明白”即可。

#### 第二期

如图 15 的子图 2 所示

- 数字按键只支持“1~9”；
- 计算功能只支持“加法、减法”；
- 辅助功能只有“等号、回退删除”；
- 显示字符数量最多 10 个；
- 界面显示“应有尽有”。

#### 第三期

如图 15 的子图 3 所示，设计的功能全都实现了。


好处：

1. 尽快出原型产品交付给用户并得到反馈，避免到了最后阶段才发现需求分析阶段出现的偏差。可以说是一种保险措施。

2. 每个开发周期都有明确的、可以实现的目标，做了这种任务分解后，开发进程变得清晰可控。对于负责技术栈中的各个层的软件工程师来说，每个开发周期只集中精力在一个功能上，其它时间可以用于框架优化，也有助于提高产品质量。

3. 验证各层之间的接口设计是否合理，可扩充性是否好。当然在产出第一个原型时，需要先把系统的基本框架搭建好，这需要花一定的时间。通常框架搭建的时间是构建整个产品的总时间的十分之一到五分之一，如果框架设计的好，接口制定得合理，后续的功能实现会非常的容易。


#### MVP（Minimum Viable Product）最小可行产品

在《构建之法》一书中的第五章已经做了一些说明，在此补充一下


<img src="Images/Slide16.JPG"/>

|比较项|概念验证|原型开发|最小可行产品|最终产品|
|--|--|--|--|--|
|生命周期|极短（日）|短（周）|中（月）|长（年）|
|成本|极低|较低|中等|最大|
|发布|不发布，仅内部使用|定向发布|阶段性发布|公开发布|
|作用|验证技术难点|确认用户需求|及时得到反馈|获得最大收益|
|风险控制|技术实现风险|需求理解风险|整体构建风险|需求、技术、人员、时间、过程等各种风险|

PoC（Proof of Concept）概念验证

目标：验证某个想法是否在技术上是可行的。

PoC背后的主要目标是测试这个想法在技术上是否可行，是否值得追求。这不是为了发现用户需要什么，或者是否有解决方案的需求，而是从技术角度来看，是否有可能并且值得追求这个想法。

毕竟，你不想对一个比你最初期望的要难10倍（而且更昂贵）实现的想法进行全面的思考。这可能是一次快速的尝试，以开发风险最大的技术假设的测试版，或者只是对现有技术可能性的更深入分析。

概念证明通常不与最终用户共享，而是用作内部工具。

特点：
- 极短的生命周期
- 极低的成本
- 为后面的原型、MVP 提供参考
- 内部使用，有时候也可以分享给甲方
- 帮助估算后期的开发时间
- 降低尝试去完成一个不可能完成的任务的风险


Prototyping 原型

目标：以最低成本收集早期反馈

原型设计努力向我们展示产品开发后的样子。虽然PoC更多地关注“引擎盖下”部分，但原型设计更多地关注UX/UI部分。目标是在预算上建立一个简单的、实验性的想法模型，以在投资实际产品之前测试和验证概念。

几乎任何东西都可以是原型——纸上的线框、数字演示、模仿网站的PowerPoint演示等等。尽早获得反馈和发现想法中的漏洞的能力可能是产品成功的决定因素

特点：
- 较短的生命周期
- 低成本
- 集中在朴素的想法实现和界面/交互部分
- 可以对整个产品做原型，也可以只针对其中的一部分做原型
- 分享给甲方，可以尽早得到反馈
- 降低与预期需求不一致的风险

MVP 最小可行产品

目标：尽快、廉价地推出产品，验证假设，收集用户反馈，并迭代。

MVP应用程序开发是关于构建一个产品版本，该版本将在市场上提供，真实用户可以与之交互。

其核心思想是在向最终用户提供价值主张的同时，尽可能少地包含功能，并满足尽可能多的市场需求。

它是关于构建产品的连续循环，然后测量和测试您的假设和猜想是否正确，收集用户的反馈，从中学习并改进产品，然后一次又一次重复。

专注于MVP开发而不是一些成熟的解决方案可以降低交付不需要的产品的风险，并允许您根据市场反应以低成本进行转向。

在真实市场上测试产品总是至关重要的，即使你已经验证了你的原型，主要是因为人们通常不知道他们想要什么，他们只是认为他们知道自己想要什么。

特点：
- 正常的功能开发生命周期
- 中等成本，大于原型的成本
- 可以发布到市场面向用户
- 验证一些假设而无需构建整个产品


<img src="Images/Slide17.JPG"/>


