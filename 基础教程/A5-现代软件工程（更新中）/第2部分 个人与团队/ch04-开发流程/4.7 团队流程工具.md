
## 4.4 故事分析






VSO

<img src="Images/Slide20.JPG"/>

- Remote：远程仓库，就是类似github，码云等网站所提供的仓库，可以理解为远程数据交换的仓库~

- Repository：本地仓库，你执行git clone 地址，就是把远程仓库克隆到本地仓库。它是一个存放在本地的版本库，其中HEAD指向最新放入仓库的版本。当你执行git commit，文件改动就到本地仓库来了~

- Index/Stage：暂存区，一般存放在 .git目录下，即.git/index,它又叫待提交更新区，用于临时存放你未提交的改动。比如，你执行git add，这些改动就添加到这个区域啦。

- Workspace：你电脑本地看到的文件和目录，在Git的版本控制下，构成了工作区。

<img src="Images/Slide22.JPG"/>



对于涉及编写代码的每个服务、库或其他功能，工程知识团队的软件开发过程应按如下方式设置：



1. 木头将源代码从远程存储库签出到本地存储库；
2. 创建一个新分支；
3. 开发：编写、运行和调试您的代码和配置更改；
4. 如果在开发期间，有团队内别的开发者提交了代码，木头需要从远程更新代码，避免奖励的冲突；
5. 提交代码并将其推送到远程存储库；
6. 创建一个 PR（Pull Request，拉取请求）以将分支合并到目标分支中；
7. 拉取请求由多个审阅者审阅，可以设置为至少有一个审阅者批准后方可；
8. 自动构建和测试管道（CI Pipeline）将验证该分支；
9. 如果测试通过，木头可以合并分支到主分支，完成拉取请求。

明明是要把修改的代码合并入主分支（Push），为什么叫拉取请求呢（Pull）？这是相对于主分支说的，是在请求主分支把修改拉进去。


1. 程序员的每一次推送，都可以触发 CI Pipeline 的运行，便于在提交 PR 之前发现一些基本的错误。
2. 如果代码审查者提出意见，程序员需要在本地修改代码并解决意见，再次提交到远程，在上次的 PR 内再次请大家审查代码，直到通过为止。


CI/CD Azure Pipline
(也许可以写在测试与质量部分)





软件工程的三要素：方法、工具、过程

方法

方法一词的产生有两个由来：

1. 与工匠有关。

    墨子说：“轮人（做车的工匠）操其规，将以度量天下之圆与不方圆。曰中吾规者谓之圆，不中吾规者谓之不圆，则圆法明也。匠人亦操其矩，将以度量天下之方与不方也。曰中吾矩者谓之方，不中吾矩者谓之不方，则**方法**明也。” 大概意思是做木工活的时候，工匠用特殊的工具来度量木材是否是圆的或方的，由此我们知道了**规矩**和**方法**的来历，只是**圆法**这个词并没有流传下来。

2. 与中医有关。

    传说我国古代有一位皇帝患上了噎膈病，进食即吐，找了很多医生开了许多方子，都没有见效。最后请来一位隐居的和尚，经过一番望、闻、问、切，拟出一方，让太监速去取药。可太监拿到药方后，不由一愣，自言自语道：“什么高明医术？这不和之前医生所开方药一模一样吗？” 和尚拿过前医所开药方一看，药味、药量均与他分毫不差，但只是沿用传统的水煎口服，而皇帝现如今是滴水不进，何况药液？于是和尚亲自把药熬好，并浓缩到只剩下两匙勺，让皇帝拿小勺把药盛到嘴里用舌头慢慢舔尽，如此反复直至把药液舔完为止。连服数剂药之后，病果然大有起色。
    
    和尚解释说：“医者，既要有方，又要有法。前医之方虽对症，但用法不对。皇上饮药反胃都吐了出来，自然不能发挥作用；而我让皇上舔取精华，量少而不反胃，乃是据症选法。” 皇帝听后，恍然大悟说道：“方法，方法，**方**与**法**结合也。” 从此，便产生了**方法**一词。

所以，方法其实是由“方”和“法”组成，方法既规矩，是一种知识体系或衡量标准。

软件工程中的方法

功能分解法
结构化分析法
结构化设计法
信息建模法
面向对象分析法
面向对象设计法


方法
工具
过程

道：思想
法：方法
术：技术
器：工具

https://zhuanlan.zhihu.com/p/137343992


https://blog.csdn.net/weixin_43914604/article/details/105047495

https://blog.csdn.net/weixin_44529208/article/details/106359025?spm=1001.2101.3001.6650.11&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-11-106359025-blog-105047495.pc_relevant_recovery_v2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-11-106359025-blog-105047495.pc_relevant_recovery_v2&utm_relevant_index=21


甲乙两个人




### 4.8.3 几种验证工具

在开发复杂的软件系统时，尤其是面对一些前所未有的功能时，没有前人经验可以借鉴，并且没有人可以确定它能做还是不能做。这时就需要一些工具来帮助人们做快速的验证。经常用到的是：

- 概念验证（PoC，Proof of Concept）
- 原型开发（Prototyping）
- 最小可行产品（MVP，Minimum Viable Product)

<img src="Images/Slide12.JPG"/>

图 4.8.3 

表 4.8.2

|比较项|概念验证|原型开发|最小可行产品|最终产品|
|--|--|--|--|--|
|生命周期|极短（日）|短（周）|中（月）|长（年）|
|成本|极低|较低|中等|最大|
|发布|不发布，仅内部使用|定向发布|阶段性发布|公开发布|
|作用|验证技术难点|确认用户需求|及时得到反馈|获得最大收益|
|风险控制|技术实现风险|需求理解风险|整体构建风险|需求、技术、人员、时间、过程等各种风险|

#### PoC（Proof of Concept）概念验证

目标：验证某个想法是否在技术上是可行的。

PoC 的主要目标是测试这个想法在技术上是否可行，是否值得追求。这不是为了发现用户需要什么，或者是否有解决方案的需求，而是从技术角度来看，是否有可能并且值得追求这个想法。

毕竟，你不想对一个比你最初期望的要难10倍（而且更昂贵）实现的想法进行全面的思考。这可能是一次快速的尝试，以开发风险最大的技术假设的测试版，或者只是对现有技术可能性的更深入分析。

比如，想实现的新功能强烈依赖的核心技术是 OCR，而自己临时做一个 OCR 是不可能的，那就需要：

1. 找到现有的商业化 OCR 解决方案去做试验；
2. 多找几个提供商，看看哪一家的识别率更好，价格更低；
3. 有条件的话后期自己做一个。

概念证明通常不与最终用户共享，而是用作内部工具。

特点：
- 极短的生命周期；
- 极低的成本；
- 为后面的原型、MVP 提供参考；
- 内部使用，有时候也可以分享给甲方；
- 帮助估算后期的开发时间；
- 降低尝试去完成一个不可能完成的任务的风险。


#### Prototyping 原型开发

目标：以最低成本收集早期反馈

原型设计努力向我们展示产品开发后的样子。虽然PoC更多地关注“引擎盖下”（用户看不见）部分，但原型设计更多地关注UX/UI部分。目标是在预算上建立一个简单的、实验性的想法模型，以在投资实际产品之前测试和验证概念。

几乎任何东西都可以是原型：纸上的线框、数字演示、模仿网站的 PowerPoint 演示等等。尽早获得反馈和发现想法中的漏洞的能力可能是产品成功的决定因素。

当然，有些原型开发也是需要代码的，这些代码可以是粗制乱造的，只要能完成任务即可。

特点：
- 较短的生命周期；
- 低成本；
- 集中在朴素的想法实现和界面/交互部分；
- 可以对整个产品做原型，也可以只针对其中的一部分做原型；
- 分享给甲方，可以尽早得到反馈；
- 降低与预期需求不一致的风险。

#### MVP（Minimum Viable Product）最小可行产品

和上面讲的垂直切片概念类似。

与“垂直切片”法的概念不完全相同，按功能，按质量评价维度

功能完整性
高可靠性
可用性
完美


目标：尽快、廉价地推出产品，验证假设，收集用户反馈，并迭代。

MVP应用程序开发是关于构建一个产品版本，该版本将在市场上提供，真实用户可以与之交互。

其核心思想是在向最终用户提供价值主张的同时，尽可能少地包含功能，并满足尽可能多的市场需求。

它是关于构建产品的连续循环，然后测量和测试您的假设和猜想是否正确，收集用户的反馈，从中学习并改进产品，然后一次又一次重复。

专注于MVP开发而不是一些成熟的解决方案可以降低交付不需要的产品的风险，并允许您根据市场反应以低成本进行转向。

在真实市场上测试产品总是至关重要的，即使你已经验证了你的原型，主要是因为人们通常不知道他们想要什么，他们只是认为他们知道自己想要什么。

特点：
- 正常的功能开发生命周期；
- 中等成本，大于原型的成本；
- 可以发布到市场面向用户；
- 验证一些假设而无需构建整个产品。


<img src="Images/Slide13.JPG"/>


在图 4.8.4 中，用金字塔形状列出了 4 层，而其内容分别是：

1. 功能正确性（Functional）
2. 高可靠性（Reliable）
3. 可用性（Usable）
4. 完美（Delightful），用户满意

为什么列出了这四个层次呢？

因为 1,2,3 三个层次都是软件质量的评判标准，虽然还有其它一些质量特性，但是针对最终用户的话，只有这三点是可以感受到的。关于质量特性我们在第 6 部分再详细介绍。

首先要求功能正确性，并不是说一次性要提供 10 个功能，而是只提供 2 个功能时，要保证这个 2 个功能是完全可以工作的，从输入、计算到输出，都是符合预期的。

其次是高可靠性，即不分时间地点的多次输入，都可以得到预期的输出。

再次是可用性，即界面友好，用户基本上不需要经过特殊培训就可以使用。用户可以方便地输入，比如当打字不方便时可以用语音输入。并且可以得到明确可见的输出。

前三者都具备的情况下，就可以是令用户满意的完美软件。



在《构建之法》一书中的第五章已经做了一些说明，在此补充一下


