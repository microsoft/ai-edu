
## 4.7 开发流程选择与工具

### 4.7.1 采用合理的开发流程

在前面的各节中我们看到，即使是在微软，也会有多种形式的团队流程。原因多种多样：

<img src="Images/Slide20.JPG"/>

图 4.7.1


那么，是不是大型软件就不能使用敏捷开发的思想呢？

以必应搜索服务为例，这是一个超大型的项目，最多时有 3000 多人合作开发：

- 2010 年，从 Live Search 改名为 Bing 后，发布周期是 6 个月；
- 3 年后，缩减到 3 个月整体发布一次；
- 再过两年，缩短到 1 个月整体发布一次；
- 质的变化发生在 2016 年，不再整体发布了，而是每个 feature team 可以自主发布，最短周期可以是星期。
- 到了 2018 年，随着系统的成熟，完全取消了发布限制，每个 feature team 可以随时发布新功能。

<img src="Images/Slide21.JPG"/>

图 4.7.2


### 4.7.2 团队开发流程代码工具

- Remote：远程仓库，就是类似github，码云等网站所提供的仓库，可以理解为远程数据交换的仓库~

- Repository：本地仓库，你执行git clone 地址，就是把远程仓库克隆到本地仓库。它是一个存放在本地的版本库，其中HEAD指向最新放入仓库的版本。当你执行git commit，文件改动就到本地仓库来了~

- Index/Stage：暂存区，一般存放在 .git目录下，即.git/index,它又叫待提交更新区，用于临时存放你未提交的改动。比如，你执行git add，这些改动就添加到这个区域啦。

- Workspace：你电脑本地看到的文件和目录，在Git的版本控制下，构成了工作区。

<img src="Images/Slide22.JPG"/>

图 4.7.3

对于涉及编写代码的每个服务、库或其他功能，工程知识团队的软件开发过程应按如下方式设置：


1. 木头将源代码从远程存储库签出到本地存储库；
2. 创建一个新分支；
3. 开发：编写、运行和调试您的代码和配置更改；
4. 如果在开发期间，有团队内别的开发者提交了代码，木头需要从远程更新代码，避免奖励的冲突；
5. 提交代码并将其推送到远程存储库；
6. 创建一个 PR（Pull Request，拉取请求）以将分支合并到目标分支中；
7. 拉取请求由多个审阅者审阅，可以设置为至少有一个审阅者批准后方可；
8. 自动构建和测试管道（CI Pipeline）将验证该分支；
9. 如果测试通过，木头可以合并分支到主分支，完成拉取请求。

明明是要把修改的代码合并入主分支（Push），为什么叫拉取请求呢（Pull）？这是相对于主分支说的，是在请求主分支把修改拉进去。


1. 程序员的每一次推送，都可以触发 CI Pipeline 的运行，便于在提交 PR 之前发现一些基本的错误。
2. 如果代码审查者提出意见，程序员需要在本地修改代码并解决意见，再次提交到远程，在上次的 PR 内再次请大家审查代码，直到通过为止。


### 4.7.3 团队开发流程管理工具

在微软一般使用 Azure DevOps 来做开发流程管理工具，只需要用浏览器访问，所有服务都部署在云端。


<img src="Images/Slide23.JPG"/>

图 4.7.4

### 4.7.4 几种验证工具

在开发复杂的软件系统时，尤其是面对一些前所未有的功能时，没有前人经验可以借鉴，并且没有人可以确定它能做还是不能做。这时就需要一些工具来帮助人们做快速的验证。经常用到的是：

- 概念验证（PoC，Proof of Concept）
- 原型开发（Prototyping）
- 最小可行产品（MVP，Minimum Viable Product)

<img src="Images/Slide24.JPG"/>

图 4.7.5

表 4.7.11

|比较项|概念验证|原型开发|最小可行产品|最终产品|
|--|--|--|--|--|
|生命周期|极短（日）|短（周）|中（月）|长（年）|
|成本|极低|较低|中等|最大|
|形式|简陋的代码|简陋的代码或无代码|可发布的代码|产品代码|
|发布|不发布，仅内部使用|定向发布后回收|阶段性发布|公开发布|
|作用|验证技术难点|确认用户需求|及时得到反馈|获得最大收益|
|风险控制|技术实现风险|需求理解风险|整体构建风险|需求、技术、人员、时间、过程等各种风险|

#### PoC（Proof of Concept）概念验证

目标：验证某个想法是否在技术上是可行的。

PoC 的主要目标是测试这个想法在技术上是否可行，是否值得追求。这不是为了发现用户需要什么，或者是否有解决方案的需求，而是从技术角度来看，是否有可能并且值得追求这个想法。

毕竟，你不想对一个比你最初期望的要难10倍（而且更昂贵）实现的想法进行全面的思考。这可能是一次快速的尝试，以开发风险最大的技术假设的测试版，或者只是对现有技术可能性的更深入分析。

比如，想实现的新功能强烈依赖的核心技术是 OCR，而自己临时做一个 OCR 是不可能的，那就需要：

1. 找到现有的商业化 OCR 解决方案去做试验；
2. 多找几个提供商，看看哪一家的识别率更好，价格更低；
3. 有条件的话后期自己做一个。

概念证明通常不与最终用户共享，而是用作内部工具。

特点：
- 极短的生命周期；
- 极低的成本；
- 为后面的原型、MVP 提供参考；
- 内部使用，有时候也可以分享给甲方；
- 帮助估算后期的开发时间；
- 降低尝试去完成一个不可能完成的任务的风险。


#### Prototyping 原型开发

目标：以最低成本收集早期反馈

原型设计努力向我们展示产品开发后的样子。虽然PoC更多地关注“引擎盖下”（用户看不见）部分，但原型设计更多地关注UX/UI部分。目标是在预算上建立一个简单的、实验性的想法模型，以在投资实际产品之前测试和验证概念。

几乎任何东西都可以是原型：纸上的线框、数字演示、模仿网站的 PowerPoint 演示等等。尽早获得反馈和发现想法中的漏洞的能力可能是产品成功的决定因素。

当然，有些原型开发也是需要代码的，这些代码可以是粗制乱造的，只要能完成任务即可。

特点：
- 较短的生命周期；
- 低成本；
- 集中在朴素的想法实现和界面/交互部分；
- 可以对整个产品做原型，也可以只针对其中的一部分做原型；
- 分享给甲方，可以尽早得到反馈；
- 降低与预期需求不一致的风险。

#### MVP（Minimum Viable Product）最小可行产品

和上面讲的垂直切片概念类似。

与“垂直切片”法的概念不完全相同，按功能，按质量评价维度

功能完整性
高可靠性
可用性
完美


目标：尽快、廉价地推出产品，验证假设，收集用户反馈，并迭代。

MVP应用程序开发是关于构建一个产品版本，该版本将在市场上提供，真实用户可以与之交互。

其核心思想是在向最终用户提供价值主张的同时，尽可能少地包含功能，并满足尽可能多的市场需求。

它是关于构建产品的连续循环，然后测量和测试您的假设和猜想是否正确，收集用户的反馈，从中学习并改进产品，然后一次又一次重复。

专注于MVP开发而不是一些成熟的解决方案可以降低交付不需要的产品的风险，并允许您根据市场反应以低成本进行转向。

在真实市场上测试产品总是至关重要的，即使你已经验证了你的原型，主要是因为人们通常不知道他们想要什么，他们只是认为他们知道自己想要什么。

特点：
- 正常的功能开发生命周期；
- 中等成本，大于原型的成本；
- 可以发布到市场面向用户；
- 验证一些假设而无需构建整个产品。


<img src="Images/Slide25.JPG"/>

图 4.7.6

中，用金字塔形状列出了 4 层，而其内容分别是：

1. 功能正确性（Functional）
2. 高可靠性（Reliable）
3. 可用性（Usable）
4. 完美（Delightful），用户满意

为什么列出了这四个层次呢？

因为 1,2,3 三个层次都是软件质量的评判标准，虽然还有其它一些质量特性，但是针对最终用户的话，只有这三点是可以感受到的。关于质量特性我们在第 6 部分再详细介绍。

首先要求功能正确性，并不是说一次性要提供 10 个功能，而是只提供 2 个功能时，要保证这个 2 个功能是完全可以工作的，从输入、计算到输出，都是符合预期的。

其次是高可靠性，即不分时间地点的多次输入，都可以得到预期的输出。

再次是可用性，即界面友好，用户基本上不需要经过特殊培训就可以使用。用户可以方便地输入，比如当打字不方便时可以用语音输入。并且可以得到明确可见的输出。

前三者都具备的情况下，就可以是令用户满意的完美软件。



在《构建之法》一书中的第五章已经做了一些说明，在此补充一下


