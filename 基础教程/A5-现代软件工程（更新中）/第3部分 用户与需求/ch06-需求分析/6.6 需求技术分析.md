# 6.6 需求技术分析

目前，软件需求的技术分析方法较多，如图 6.6.1 所示，有一些大同小异，而有的则基本思路相差很大，比如有自下而上的，也有自上而下的，这两者的思路正好相反。笔者提倡自上而下由全局出发全面规划分析，然后逐步设计实现。

<div align="center">
<img src="Images/Slide23.JPG"/>

图 6.6.1 - 需求技术分析的各种方法
</div>

在这一节中，我们泛泛地介绍各种需求技术分析方法，只要求大家知道有这些方法存在，不要求全部掌握，有兴趣的读者可以自己做深入研究。最后我们会详细介绍面向对象的分析方法，这是本书中要重点介绍的方法。

## 6.6.1 软件需求分析方法

从系统分析出发，可将需求分析方法大致分为功能分解方法、结构化分析方法、信息建模法和面向对象的分析方法。$^{[1]}$

### 功能分解方法

将新系统作为多功能模块的组合，各功能也可分解为若干子功能及接口，子功能再继续分解，便可得到系统的雏形，即公式 6.6.1 所示：

$$
功能分解 = 功能 + 子功能 + 功能接口 \tag{6.6.1}
$$

对于一个比较小的软件，或者是一个大系统中的局部功能，可以使用这种简便的方法。

### 结构化分析方法

结构化分析方法是由数据流图和数据词典构成并表示，所以此分析法又称为数据流法。其基本策略是跟踪数据流，即研究问题域中数据流动方式及在各个环节上所进行的处理，从而发现数据流和加工方法。结构化分析可定义为数据流、数据处理或加工、数据存储、端点、处理说明和数据字典。

$$
\begin{aligned}
数据流图 =& 数据流 + 数据处理 + 数据存储 + 端点 \\
数据说明 =& 端点说明 + 处理说明 + 数据字典 \\
结构化分析 =& 数据流图 + 数据说明
\end{aligned} \tag{6.6.2}
$$

结构化分析法和下面要说的面向对象分析法，并不是对立的，二者可以配合使用。因为在刚开始进行分析时，不可能马上就能发现真正的“对象”，而用数据流图可以重现真实需求，帮助分析人员逐步进入状态，这也是笔者多年的经验。

### 信息建模方法

信息建模可定义为实体或对象、属性、关系、父类型/子类型和关联对象。此方法的核心概念是实体和关系，最初由 P.P.S. Chen 在1976年提出，基本工具是 E-R 图。1981年 M.Flavin 改进后称之为信息建模法，后来又发展为语义数据建模法，并引入了面向对象的特定。其基本要素由实体、属性和联系构成。该方法的基本策略是从现实中找出实体，然后再用属性进行描述。

$$
\begin{aligned}
内部信息 =& 实体或对象 + 属性 \\
外部信息 =& 关系 + 父子类型 + 关联对象 \\
信息建模 =& 内部信息 + 外部信息
\end{aligned} \tag{6.6.3}
$$

### 面向对象的分析方法

  面向对象的分析方法的关键是识别问题域内的对象，分析它们之间的关系，并建立三类模型，即：

  - 对象模型
  - 动态模型
  - 功能模型

  面向对象主要考虑类或对象、结构与连接、继承和封装、消息通信，只表示面向对象的分析中几项最重要特征。类或对象是对问题域中事物的完整映射，包括事物的数据特征（即属性）和行为特征（即服务）。

$$
\begin{aligned}
实体 =& 对象或类 + 结构与连接 \\
特征 =& 继承 + 封装 + 消息通信 \\
 =& 数据特征 + 行为特征 \\
面向对象分析 =& 实体分析 + 特征分析
\end{aligned} \tag{6.6.4}
$$

由于面向对象分析方法的先进性和重要性，我们在下面着重介绍一下。

## 6.6.2 面向对象的分析方法

OOA（Objec-Oriented Analysis），面向对象的分析方法，目前已经衍生出许多方法，每种方法都有各自的进行产品或系统分析的过程，都有一组可描述过程演进的图形标识，以及能使得软件工程师可以理解一致的符号体系。

<div align="center">
<img src="Images/Slide24.JPG"/>

图 6.6.2 - 面向对象的分析方法
</div>

现在广泛使用的 OOA 方法有以下几种：

### Booch 方法

Booch 方法包含“微开发过程”和“宏开发过程”。微开发过程定义了一组任务，并在宏开发过程的每一步骤中反复使用它们，以维持演进途径。Booch OOA 宏开发过程的任务包括标识类和对象、标识类和对象的语义、定义类与对象间的关系，以及进行一系列求精从而实现分析模型。

### Rumbaugh 方法

Rumbaugh 和他的同事提出的对象模型化技术（OMT）用于分析、系统设计和对象级设计 。分析活动建立三个模型：对象模型（描述对象、类、层次和关系），动态模型（描述对象和系统的行为），功能模型（类似于高层的DFD，描述穿越系统的信息流）。

1. 建立对象模型

   面向对象分析首要的工作，是建立问题域的对象模型。这个模型描述了现实世界中的“类与对象”以及它们之间的关系，表示了目标系统的静态数据结构。静态数据结构对应用细节依赖较少，比较容易确定；当用户的需求变化时，静态数据结构相对来说比较稳定。因此，用面向对象方法开发绝大多数软件时，都首先建立对象模型，然后再建立另外两个子模型。

   对象模型通常有5个层次，基本的工作步骤是：

   - 确定对象和类（object and class）
      
     这里所说的对象是对数据及其处理方式的抽象，它反映了系统保存和处理现实世界总某些事物的信息能力。
     
     类是多个对象的共同属性和方法集合的描述，它包括如何在一个类中建立一个新对象的描述。

   - 确定结构（structure）
  
     结构是指问题域的复杂性和连接关系。类成员结构反映了泛化—特化关系，整体—部分结构反映整体和局部之间的关系。

   - 确定主题（subject）
    
     主题是指事物的总体概貌和总体分析模型。

   - 确定属性（attribute）

     属性就是数据元素，可用来描述对象或分类结构的实例。

   - 确定方法（method）
    
     方法是在收到消息后必须进行的一些处理方法。


2. 建立动态模型

   - 第一步，编写典型交互行为的脚本。虽然脚本中不可能包括每个偶然事件，但是，至少必须保证不遗漏常见的交互行为。
  
   - 第二步，从脚本中提取出事件，确定触发每个事件的动作对象以及接受事件的目标对象。
  
   - 第三步，排列事件发生的次序，确定每个对象可能有的状态及状态间的转换关系，并用状态图描绘它们。
  
   - 最后，比较各个对象的状态图，检查它们之间的一致性，确保事件之间的匹配。

3. 建立功能模型

   功能模型表明了系统中数据之间的依赖关系，以及有关的数据处理功能，它由一组数据流图组成。其中的处理功能可以用IPO（Input/Processing/Output，输入/处理/输出）图（或表）、伪码等多种方式进一步描述。通常在建立对象模型和动态模型之后再建立功能模型。

### Coad 和 Yourdon 方法

Coad 和 Yourdon 方法常常被认为是最容易学习的 OOA 方法。建模符号相当简单，而且开发分析模型的导引直接明了。其 OOA 过程概述如下：

1. 使用“要找什么”准则标识对象；
2. 定义对象之间的一般化∕特殊化结构；
3. 定义对象之间的整体∕部分结构；
4. 标识主题（系统构件的表示）；
5. 定义属性及对象之间的实例连接；
6. 定义服务及对象之间的消息连接。

### Jacobson方法

也称为 OOSE（面向对象软件工程）。Jacobson方法与其他方法的不同之处在于他特别强调使用实例（use case）——用以描述用户与系统之间如何交互的场景。Jacobson方法概述如下：

1. 标识系统的用户和它们的整体责任；
2. 通过定义参与者及其职责、使用实例、对象和关系的初步视图，建立需求模型；
3. 通过标识界面对象、建立界面对象的结构视图、表示对象行为、分离出每个对象的子系统和模型，建立分析模型。

### Wirfs-Brock 方法

Wirfs-Brock 方法不明确区分分析和设计任务。从评估客户规格说明到设计完成，是一个连续的过程。与 Wirfs-Brock 分析有关的任务概述如下：

1. 评估客户规格说明；
2. 使用语法分析从规格说明中提取候选类；
3. 将类分组以表示超类；
4. 定义每一个类的职责；
5. 将职责赋予每个类；
6. 标识类之间的关系；
7. 基于职责定义类之间的协作；
8. 建立类的层次表示；
9. 构造系统的协作图。

### 统一的OOA方法（UML）

统一的建模语言（UML）已经被广泛使用，它把 Booch、Rumbaugh和Jacobson 等各自独立的 OOA 和 OOD 方法中最优秀的特色组合成一个统一的方法。在 UML 中用 5 种不同的视图来表示一个系统，这些视图从不同的侧面描述系统。每一个视图由一组图形来定义。这些视图形成一个序列，如图 6.6.3 所示：

<div align="center">
<img src="Images/Slide25.JPG"/>

图 6.6.3 - UML 中的模型视图
</div>


1. 用户模型视图
   
   也可以叫做功能模型。

   这个视图从用户（ 在UML中叫做参与者）角度来表示系统。它使用用例（use case）来建立模型，并用它来描述来自终端用户方面的可用的场景，在 6.7 节中讲述。
   
2. 结构模型视图
   
   也可以叫做对象模型。

   从系统内部来看数据和功能，即对静态结构（类、对象和关系）模型化，在 6.8 节中讲述。
   
3. 行为模型视图
   
   也可以叫做动态模型。

   这种视图表示了系统状态和行为，还描述了在用户模型视图和结构模型视图中所描述的各种结构元素之间的交互和协作，在 6.9 节中讲述。
   
4. 实现模型视图
   
   将系统的结构和行为表达成为易于转换为实现的方式，在本书的第 5 部分中讲述。
   
5. 环境模型视图
   
   表示系统实现环境的结构和行为，在本书的第 5 部分中讲述。

通常，UML 需求分析建模的注意力放在系统的用户模型和结构模型视图，而 UML 系统设计建模则定位在行为模型、实现模型和环境模型。但是正如 6.9 节中将要学习到的，行为模型有两种：一种是还原现实世界的行为，属于需求分析的范畴；另外一种是在计算机的数字世界中设计新的行为模型，后者是对前者的抽象和扩充。

## 6.6.3 小结

### 各种需求分析方法的比较

上面介绍了很多中需求分析方法，各有各的侧重点。笔者仔细分析了整个需求分析的脉络后发现，其实这些方法都是遵从表 6.6.1 中的基本步骤。

表 6.6.1 - 各种需求方法的比较

|步骤|功能分解法|结构化分析法|信息建模法|面向对象法|UML法|
|--|--|--|--|--|--|
|1. 描述原始需求|功能|系统关系图，顶层数据流图|原始信息|功能模型|用户模型|
|2. 提取静态结构|子功能|数据存储，端点|对象和属性|对象模型|结构模型|
|3. 捕捉动态行为|功能接口|数据处理，数据流|关系类型，关联对象|动态模型|行为模型|

表 6.6.1 的内容，需要对各种方法仔细研究后才能理解，最后的结论是，无论哪种方法，都可以异曲同工地达到需求分析的目的，所以在实践中可以选取一种方法为主导，混用一些其它的自己熟悉的分析方法。

### 需求分析与系统设计的分界线

在面向对象法中，要求建立对象模型、动态模型、功能模型。其实这个理论本身已经偏向系统分析/设计了，对很多需求分析的内容并不涵盖。在很多资料上并没有介绍具体如何做，导致很多人在实践中把分析和设计阶段的任务混为一谈。

为什么这种情况能一直持续下去呢，一个重要原因是在一般的软件公司里，总会有一位“领域专家”，往往是他/她既做需求分析，又做系统设计。在微软其实也是这样，没有各自独立的角色分别做需求分析和系统设计两件事，往往是一个从底层做起的程序员，逐渐成长为领域专家后，再去负责需求分析与系统设计的工作。

这样做的好处显而易见：合并需求分析和系统设计两个过程，能够敏捷开发，快速迭代，用 MVP（Minimum Viable Product，最小可行产品）理念实现软件产品，逐步完善。

但问题也是存在的：

1. 他/她在做需求分析（做什么）的时候，脑子里会不自觉地想到如何去实现（如何做），这样就混淆了“做什么”和“如何做”；
2. 写出来的文档没有边界；
3. 定义出来的类会让后续的开发人员感觉到限制；
4. 隐藏了一些真实的用户需求，而用自己的理解直接代替。

这会带来什么问题呢？该员工一旦离职，这个项目就垮掉了，因为所有的东西都在他脑子里。

用一个简单的比喻帮助大家理理解它们的分界线：我们在做需求分析的时候，可以把每个角色、实体、模块等等都看作一个鸡蛋，它们在需求分析阶段都是不透明的，我们也不需要在需求分析阶段去窥探鸡蛋内部的构造，否则的话，我们会得到一堆破鸡蛋——所有的蛋液流出来并混在一起，造成无法进行下一步的分析。

这个鸡蛋壳，就处于上述的“统一的 OOA 方法”的5个视图中的第3个上，如图 6.6.3 中的分界线所示。

笔者在多年的软件工程实践中也总结出了一套方法，经过与各种模型、理论的对比，发现竟然与“统一的 OOA 方法”完全一致！所以，我们会在后续的章节中通过真实的案例继续介绍这种方法。

