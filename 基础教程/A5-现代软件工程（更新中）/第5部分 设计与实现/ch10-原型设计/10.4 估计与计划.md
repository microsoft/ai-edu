# 10.4 估计与计划

如果是轻车熟路的项目，PM 很容易根据历史经验估算出开发时间，依次指定计划，完成PM Spec。但是如果是一个与已有产品有部分不同或者完全不同的项目，就需要先做原型开发，验证一些技术关键点之后，才能有比较准确的估计。

## 10.4.1 成本估算模型

COCOMO是COnstructive COst MOdel（建设性成本估算模型）的缩写，最早是由Dr. Barry Boehm在1981年提出，是一种精确的、易于使用的成本估算方法。 COCOMO II模型的原型是在1996年提出，并持续改进。由于其采用了模型化的管理方法，在国外有很高的影响力。由于国内现有的软件开发项目数据还不是很完善，该方法在国内的使用还是受到限制。所以很多资料以及参数只能从国外的网站上去参考。而参数的准确性，则由于文化、开发背景、技术熟练度、编程环境和成本等的差异，不能直接使用在现有开发项目中，只能作为大致的参考。

软件项目分为五种：

1. 基础软件
2. 系统集成
3. 程序自动化生成
4. 应用集成
5. 最终用户编程

规模从大到小变化，难易程度也是同样。COCOMO 有三个子模型来支持上述五种软件项目：

1. 应用构图（Applications Composition）
   
   通过原型开发解决人机交互、系统接口、技术成熟度等具有潜在高风险的内容。

2. 早期设计（Early Design）
   
   支持确立软件体系结构的生命周期阶段。

3. 后体系结构（Post-Architecture）

   在项目确定开发之后，对软件功能结构基本了解，通过代码行数或功能点数来计算工作量和进度，使用5个规模度因子和17个成本属性驱动因子调整计算公式。

COCOMO II 模型的使用场景如下：

1. 做出涉及软件开发工作的投资或其他财务决策；
2. 制定项目预算和时间表作为计划和控制的基础；
3. 决定或协商软件成本、进度、功能、性能或质量因素之间的权衡；
4. 制定软件成本和进度风险管理决策；
5. 决定开发、重用、租赁或购买软件系统的哪些部分；
6. 制定遗留软件库存决策：修改、逐步淘汰、外包等；
7. 通过重用、工具、过程成熟度、外包等，设置混合投资策略来提高组织的软件能力。

## 10.4.2 项目的规模度

我们先了解一下规模度的概念，见图 10.4.2。

<div align="center">
<img src="Images/Slide17.JPG"/>
图 10.4.2 - 规模度因子
</div>

举例来说，某个项目在图10.4.2中满足下列条件：

1. $PREC = 2.48$，即有前例可以借鉴，程度为“高”；
2. $FLEX = 3.04$，即开发灵活性为“正常”；
3. $RESL = 5.65$，即架构水平与风控能力“低”；
4. $TEAM = 1.10$，即团队成熟度“非常高”；
5. $PMAT = 4.68$，即过程成熟度为“正常”。

则根据公式10.4.1：

$$
B = 0.91 + \frac{1}{100}\sum_{i=1}^5{W_i} \tag{10.4.1}
$$

计算得到B值为：

$$
B=0.91+(2.48+3.04+5.65+1.10+4.68)/100=1.0795
$$

## 10.4.3 工作量评估

我们用 PM（People Month，人月）来估算软件开发的工作量，如公式10.4.2所示。

$$
PM = A \times Size^B \tag{10.4.2}
$$

这里的$A$通常取常数2.94，$Size$是代码行数（千行），$B$是公式10.4.1的结果值。

假设一共4万行代码，则：

$$
PM = 2.94 \times (40000/1000)^{1.0795}=2.94 \times 53.63=157.67(人月)
$$

## 10.4.4 成本驱动属性

成本驱动属性因子的加入，扩展了基本模型的能力。17个成本驱动属性因子可以分为4个部分，如图10.4.3所示。

<div align="center">
<img src="Images/Slide18.JPG"/>
图 10.4.3 - 成本驱动属性因子
</div>

表 10.4.2 给出了原文，便于大家进一步查找资料学习。

表 10.4.2 - 后体系结构模型的成本驱动属性

|序号|缩写|原文|中文|分类|
|--|--|--|--|--|
|1|RELY|Reliability|可靠性|产品|
|2|DATA|Data Base Size|数据库大小|产品|
|3|CPLX|Complexity|复杂度|产品|
|4|RUSE|Required Reusability|可重用需求|产品|
|5|DOCU|Documentation|文档完备性|产品|
|6|TIME|Execution Time Constraint|执行时间（性能）限制|平台|
|7|STOR|Main Storage Constraint|主存储限制|平台|
|8|PVOL|Platform Volatility|平台波动性（执行环境）|平台|
|9|ACAP|Analyst Capability|分析员能力|人员|
|10|PACP|Programmer Capability|开发人员能力|人员|
|11|AEXP|Applications Experience|应用开发经验|人员|
|12|PEXP|Platform Experience|平台开发经验|人员|
|13|LTEX|Language & Tool Experience|语言沟通和管理工具|组织|
|14|PCON|Personnel Continuity|人员连续（流动）性|组织|
|15|TOOL|Use of Software Tools|软件工具的使用熟练度|组织|
|16|SITE|Multi-site Development|多地合作开发|组织|
|17|SCED|Required Schedule|进度要求|组织|

通常以上因子的取值范围在 $[0.70,1.65]$ 之间，其中：
- 产品属性和平台属性是正向指标，即，该类因子级别越高，数值越大；
- 人员属性和组织属性是反向指标，即，该类因子基本越高，数值越小。

所有的因子相乘，得到工作量调节因子EAF：

$$
EAF = \prod_{i=1}^{17}{EM_i} \tag{10.4.3}
$$

公式10.4.4是在公式10.4.2的基础上，考虑了成本驱动属性后的改进：

$$
PM = A \times Size^B \times EAF \tag{10.4.4}
$$

在针对每个属性取值后，我们假设公式10.4.3的乘积结果为1.13。仍然用前面的数值例子，计算得到：

$$
PM = 2.94 \times 53.63 \times 1.13 = 178.17（人月）
$$

## 10.4.5 微软常用的估计方法

用 COCOMO 模型的问题是，代码行数通常是开发完毕后才知道的，所以有一个改进的办法是，把$Size$值改成子模块数。一般一个子模块的代码行数在500~2000行之间，可以大致与 KLOC（Kilo Line of Code）相当。

在微软通常使用T-Shirt Size方法来估算开发时间，具体见图10.4.4。

<div align="center">
<img src="Images/Slide19.JPG"/>
图 10.4.4 - T-Shirt Size估算法
</div>

这是一种简化的方法。既然用复杂的模型很难计算出准确的数值，那么我们干脆就使用一些简化的模型来估算。

首先，根据软件复杂程度的不同，把它们分成了三类：
1. 复杂，大于30万行代码；
2. 中等，介于5万到30万行代码之间；
3. 简单，小于5万行代码。

其次，给每个功能点或者模块赋予一个 T-Shirt（T恤衫）尺寸，尺寸分为5级：
1. XS，Extremly Small，特小号；
2. S，Small，小号；
3. M，Middle，中号；
4. L，Large，大号；
5. XL，Extremly Large，特大号。

根据软件复杂度，每个功能点或模块所需要的时间也是不同的，见图10.4.4中的表格。

最后，我们把所有的功能点或模块所需要的时间相加，就是该软件总共需要的开发时间。

还有一个经验是，以简单软件为例，通常没有超过5天的功能点或模块，如果超过了，就要把该模块继续分解成若干小模块，所有小模块的尺寸都必须小于等于M，这样就可以比较准确地估算整体工作量。

当然，以上的估算方法也是以团队成熟度为前提的。图 10.4.4 的右半部分给出了一个示意：假设有一个 M 尺寸的模块，对于成熟团队来说很快就可以完成，而对于稚嫩的团队来说，尺寸可能会增加到 L。
