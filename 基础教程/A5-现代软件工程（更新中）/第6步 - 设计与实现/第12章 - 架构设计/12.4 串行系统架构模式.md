
## 12.3 串行系统架构模式


### 12.3.1 管道-过滤器模式 (Pipe-filter pattern)

见图 12.3.1。

<img src='img/Slide15.svg'>

图 12.3.1 管道-过滤器架构

#### 架构说明

这种架构是可以非常自然地产生的，因为它符合人们按部就班地做事的习惯，和我们每个开发者刚开始学习的流程图和结构化开发也很类似。这种方结构有一个数据起点（原始数据）、一个数据汇点（处理好的数据）、N 个过滤器（处理逻辑）和 N+1 个管道组成，我们常说的 Pipeline 就是这个机制。

其中：
- 数据起点和汇点可能是数据库或者数据文件（源代码也可以看作是数据）。
- 过滤器一般都是可独立运行的模块，被动（被主控程序调度）或主动（常驻进程）地把数据从前面的管道拉入（pull），处理好后推入后面的管道（push）。
- 管道可以是内存中的各种数据结构、系统管道，或者是临时放在磁盘中的文件（这种情况要注意定时清理临时文件，避免磁盘被占满）。

#### 扩展模式

允许一个过滤器把数据分可后分别推送到不同的管道中，以便后续的不同逻辑的过滤器处理，甚至有可能进入不同的数据汇点。或者是在一开始，就有不同的数据源进入，但是共享某些过滤器（这种情况一般是分当作两个 pipeline 处理）。

#### 优缺点

优点：

- 很容易通过增加新的过滤器来扩展整个 pipeline 的功能。
- 可复用性好，因为每个过滤器都可以完成独立的处理功能，所以可以应用于任何其它系统中相同的场景。
- 同分层结构一样，事先定义好的接口可以运行并行开发、测试、集成。

缺点：

- 性能较低，一般用于非实时系统的后同数据处理流程中。
- 数据传输和转换开销大，注意中间数据存储要及时清理。

#### 应用场景

在 Unix 系统中的 Shell，就是一个管道模式的例子，比如：

```
cat a.txt | grep 'food' | sort | uniq > out
```
这个命令行首先用 cat 命令把 a.txt 中的文本行取出来，送给 grep 命令，把其中含有 'food' 的行取出来，送给 sort 命令，排序后把结果送给 uniq 命令去重，最后输出到 out。


管道过滤器模式的另外一个例子是编译器，如图 12.3.2 右侧所示。其中一个词法分析器分析源文件并将生成的符号序列发送到解析器，产生语法树，再由语义分析器产生增强语法树。然后由代码生成器用来生成字节代码，这些代码被优化后，并最终被翻译成机器代码（可能需要更多或更少的步骤）。


### 12.3.2 分层模式

见图 12.3.2。

<img src='img/Slide14.svg'>

图 12.3.2 分层架构

#### 架构说明

分层模式用于对软件系统进行层次拆解，每个层次都是独立的抽象，包含一组子模块，为其上层提供服务。其目的主要是为了分散关注、松散解耦、逻辑复用、标准定义。由于其众多的优点，已经成为典型的软件系统架构，也已经成为构建企业软件的标准。

一个好的分层式结构，可以使得开发人员的分工更加明确。一旦定义好各层次之间的接口，负责不同逻辑设计的开发人员就可以**分散关注**，齐头并进。例如 UI 人员只需考虑用户界面的体验与操作，领域的设计人员可以仅关注业务逻辑的设计，而数据库设计人员也不必为繁琐的用户交互而头疼了。每个开发人员的任务得到了确认，开发进度就可以迅速的提高。

**松散耦合**的好处是显而易见的。如果一个系统没有分层，那么各自的逻辑都紧紧纠缠在一起，彼此间相互依赖，谁都是不可替换的。一旦发生改变，则牵一发而动全身，对项目的影响极为严重。

降低层与层间的依赖性，既可以良好地保证未来的可扩展，在**复用性**上也是优势明显。每个功能模块一旦定义好统一的接口，就可以被各个模块所调用，而不用为相同的功能进行重复地开发。

进行好的分层式结构设计，**标准定义**也是必不可少的。只有在一定程度的标准化基础上，这个系统才是可扩展的，可替换的。而层与层之间的通信也必然保证了接口的标准化。

#### 扩展模式

- 有些时候也可以跨层调用，比如从 第 3 层直接调用第 1 层的功能。
- 同一层中有可能有两个独立的组，它们之间没有关系，只是根据上层业务逻辑提供不同的、独立的服务。

#### 优缺点

优点：

- 下层可以为所有的上层提供服务，调用灵活。一般不允许平级调用，否则被调用者就应该放在下一层。
- 高内聚，低耦合，每一层都有标准化抽象。
- 上下层之间指定好接口后，可以分组独立开发。
- 测试、集成、排查错误、升级维护等都比较容易。

缺点：

- 逐层调用会降低系统性能，需要每一层都有相应的提高性能的措施。
- 有时会导致级联的修改，这种修改尤其体现在自上而下的方向。如果在表示层中需要增加一个功能，为保证其设计符合分层式结构，可能需要在相应的业务逻辑层和数据访问层中都增加相应的代码。
- 代码量变多，肯定比都聚合在一起的代码量大。

分层后代码量自然要比不分层多

#### 应用场景

一个复杂的应用系统通常被拆分为以下四个层次，如图 12.3.1 右侧所示：

- 表示层（也称为 UI 层）
- 应用层（也称为服务层）
- 业务逻辑层（也称为领域层）
- 数据访问层（也称为持久化层）

这几乎成为了行业标准。有时候应用层和业务逻辑层也可以合并，变成标准的三层架构。

而在开放系统互联标准协议中，一共定义了 7 层，从下到上分别为：

- 物理层，比如光纤、同轴、双绞线设备。
- 数据链路层，提供物理编址、错误校验、数据帧序列生成、流量控制。
- 网络层，IP 协议在这一层实现，如确定 IP 地址并建立连接。
- 传输层，TCP 协议在这一层实现，用于可靠地传输数据。
- 会话层，SSL、TLS 等安全协议在这一层实现。
- 表示层，加密解密、压缩解压缩。
- 应用层，FTP、HTTP、POP3、SMTP 等重要协议都在这一层实现。

