
## 12.5 树形系统架构模式

### 12.5.1 主从模式（Master-Slave/Primary-Secondary）

因为 Slave 这个词比较敏感，因此英文中更多地使用 Primary-Secondary，我们只要知道 Slave 不是“奴隶”的意思就好。见图 12.5.1。

<img src='img/Slide15.svg'>

图 12.5.1 主从模式

#### 架构模式

这种模式由两部分组成：主节点和从节点。主节点将工作分配给不同的从节点，并根据从节点返回的结果计算最终结果。图 12.5.1 右侧显示了主从节点之间分配工作的顺序图，其中有一个硬性的要求：初始任务必须是可以**分割**的。

主从模式是分治（divide-and-conquer）原则的一个例子。每个从节点都是独立的，没有任何共享状态，因为它们是并行运行，或者是在同一个主机的不同进程中，或者是在不同的主机上，所以主从通信的延迟可能是一个问题。

#### 优缺点

优点：

- 读写分离。
- 适合读多写少的场景，大并发读取时，多个从节点可以提供负载均衡。
- 从节点数量扩展灵活。
- 不怕数据丢失，有很多个备份。

缺点：

- 同步延迟问题，主从节点上的数据在某一时刻有可能不一致，不适合于要求一致性高的场合。
- 如果有大量写操作，会集中在主节点上。
- 主节点发生故障会比较麻烦，自动切换的复杂度高。

#### 应用场景

那么什么叫做可以分割？注意“分割”这个词比较生硬，它并非智能地“分解”，也非理性地“分析”。有几种应用：

- 并行计算：把一批数据或任务整齐地拆分成 N 份儿，然后分配给 N 个从节点去处理。比如大规模的并行计算时，可以把多个矩阵的运算分配给多个从节点并行完成，再在主节点中合并。
- 容错：主节点把同一个计算任务分配个多个从节点，然后从最快结束运算的从节点那里获得返回结果，并返回给调用者；或者是比较所有从节点的返回结果，取相似性最高的结果（三个结果是1.512，一个结果是1.511，则取1.512），返回给调用者。
- 提供准确度：不同的从节点执行同一个任务，但是它们各自的实现方式不同，比如，一个是用神经网络推理，一个用线性回归做预测，还有一个用表格匹配法取近似值，最终在主节点上用一种策略来决定最佳结果，如平均值或最多相似值。
- 数据库复制：主数据库被视为权威源数据库，从数据库与之同步。在有读取请求时，主数据库把请求转给从数据库，以提高并非读取的速度；在有写入请求时，只发生在主数据库上，然后再同步给从数据库。


### 12.5.2 代理模式 (Broker pattern)

#### 几种“代理”的区别

本小节中描述的代理都是具备 **A$\leftrightarrow$代理$\leftrightarrow$B 三个角色**的，其中，代理帮助 A 完成访问 B 的任务，但形式上有细微差别，见表 12.5.1 和图 12.5.2。

表 12.5.1 几种“代理”的区别

|英文|中文/性质|解释|比喻|
|-|-|-|-|
|Agent|自主性代理<br>独立主体<br>有独立决策能力|A 不知道 B 或 C 的存在。<br>代理接收到 A 的请求，自主决定访问 B 还是访问 C，然后把返回结果告诉 A。|各国驻联合国代表；<br>保险公司的代理代表<br>保险公司的利益|
|Broker|中介性代理<br>独立主体<br>无自主决策<br>能力|B 在代理注册，A 通过代理得知 B 的存在，但不知道如何访问 B。<br>A 发送请求给代理，代理把该请求变成 B 可以听懂的语言发送给 B 并获得结果返回给 A|股票经纪人；<br>保险代理代表客户的<br>利益；<br>各类专卖店|
|Proxy|透传性代理<br>非独立主体|A 知道 B 的存在，但不能直接访问 B。<br>代理把 A 的请求原封不动地传给 B，再把 B 的响应原封不动地回传给 A。|语言翻译；<br>代理服务器|

还有一种叫做 Delegate 即“委托性代理”的概念，它只涉及两个方面的角色，即委托人和被委托人，没有第三方，所以不符合本节中的“代理”概念。

<img src='img/Slide20.svg'>

图 12.5.2 代理模式

#### 架构说明

在复杂系统中经常遇到的情况是，服务器可能暂时不能用，或者是有比以前更多的服务器可用，但是客户端并不知道。所有有必要增加一个中间代理来解决这个问题。见图 12.5.2。

该模式由三部分组成：

- 服务器，提供服务，并向代理注册，以便让客户端知道自己的调用方法或者访问位置。
- 代理，保持注册信息，当客户端的请求到达时，根据注册信息访问服务器，并把结果传回客户端。
- 客户端，向代理发出服务请求。

代理模式用于在结构化系统中对组件解耦。系统内各组件间采用远过程调用（remote service invocations）的方式交互。代理（Broker）组件充当组件间通讯的协调角色。服务器将其能力（服务以及特性）发布（注册）给代理，客户端均向代理请求服务，由代理将请求重定向到先前已发布过对应服务的服务器进行处理。

以上是 Broker（中介性代理）的典型行为。对于 Agent 和 Proxy 代理有一些例外情况：服务器不需要向代理注册，代理预先知道服务器的能力和访问地址。

对于 Broker 模式，客户端很可能存在一个 proxy API，客户端软件在本地调用这个 proxy API 提供的方法，这个 proxy API 负责访问远程的 Broker 或服务器来完成服务请求。这就简化了客户端的开发复杂度，通信过程由 proxy API 来完成。

#### 优缺点

优点：
- 允许动态更改、添加、删除和重新定位服务，符合开闭原则。
- 在一定程度上降低了系统的耦合度。
- 可以增加额外的保护措施来做权限分级和保护服务器。

缺点：

- 要求对服务描述进行标准化，使用代理模式时则需要考虑异步处理机制、协议创建流程和错误环境控制，比较的繁琐。
- 可能会造成请求的处理速度变慢，甚至带来通信瓶颈。
- 实现代理模式需要额外的或重复的工作，不易开发。

#### 应用场景

局域网中的计算机都没有公网的 IP 地址，所以必须通过代理服务器访问互联网上的任何主机。而通过代理即使能访问很多国内网站了，但是有些国外的网站无法访问，这样就必须通过一个特殊的网关去访问，也叫做代理。需要在客户端做配置，指明代理服务器的地址。

以上情况中，服务器只能知道代理的存在，而不知道真正的客户端是谁，这叫做正向代理。下面的情况正相反：请求来源很明确，但是不知道是哪个服务器来响应。比如 Nginx 服务器把客户端的请求按照一定的规则发送给后端的诸多服务器之一处理，而客户端不需要任何特殊配置。这叫做反向代理，它代理的是服务器端。负载均衡就是一种反向代理。

图 12.5.2 右侧的流程实例中，有两种方式：

初始化：

1. 服务器 1 向代理注册（也可能不需要注册，适用于 Agent 和 Proxy 模式）；
2. 服务器 2 向代理注册（适用于 Broker 模式）。


方式一（直连）：

1. 客户端发起请求 1；
2. 代理告诉客户端服务器 1 的地址；
3. 客户端直接发请求给服务器 1；
4. 服务器 1 返回结果 1 给客户端。

DNS 就属于第一种方式，但是并不是典型的代理模式。

方式二（转发）：

1. 客户端发起服务请求 2；
2. 代理把服务请求 2 转发给服务器 2；
3. 服务器 2 返回结果 2 给代理；
4. 代理把结果 2 转发给客户端。

这是典型的代理模式的行为。

### 12.5.3 事件总线模式 (Event-bus pattern)

#### 架构说明

事件总线模式应用于事件处理，主要由四个组件构成：事件源（event source），事件侦听者（event listener），通道（Channel）以及总线（event bus）。 事件源将消息发布到总线的特定通道，侦听者订阅相应的通道，事件源所发布的消息经通道通告给订阅通道的侦听者。

见图 12.5.3 拓扑结构。

<img src='img/Slide21.svg'>

图 12.5.3 事件总线模式

一个事件源一般只发送消息到一个通道中，该通道一般由消息队列实现。而监听者根据业务需求可以监听一个或多个通道内的消息，比如图 12.5.3 中的监听者 1 就同时监听通道 1 和通道 2 的消息，此时，事件源 2 要发送两个消息拷贝到通道 2 中。

#### 优缺点
事件驱动架构模式实现起来相对复杂，主要是由于它的异步和分布式特性。这可能会带来一些分布式的问题，比如远程处理的可用性，缺乏响应，broker重连等问题。

优点：

- 分布式的异步架构，事件处理器之间高度解耦，软件的扩展性好
- 适用性广，各种类型的项目都可以用
- 性能较好，因为事件的异步本质，软件不易产生堵塞
- 事件处理器可以独立地加载和卸载，容易部署

缺点：

- 涉及异步编程（要考虑远程通信、失去响应等情况），开发相对复杂
- 难以支持原子性操作，因为事件通过会涉及多个处理器，很难回滚
- 分布式和异步特性导致这个架构较难测试
- 模式分析


#### 应用场景

这里用一个网络购物的应用常见来说明事件总线的应用方式，见图 12.5.3 右侧订单服务实力。

1. 一个网络购物的用户下了订单，应用程序会发送“订单事件”到事件总线；
2. “订单处理”模块会得到“订单处理通知”，处理订单，比如核对存货量、配送地、付款信息等；
3. 处理完毕后发送“订单确认事件”到事件总线；
4. “订单确认”模块会得到“订单确认通知”，给用户发送确认短信或使用其他通信手段；
5. 发送消息给用户；
6. 发送完毕后发送“通知成功事件”到事件总线；
7. “订单执行”模块会得到“订单配送通知”；
8. 商家配送，送货上门，用户签收；
9. 配送完成后发送“订单完成事件”到事件总线。
10. (未画出）系统发送“用户评价通知”然后关闭该订单。

这种应用场景相当复杂，如果用串行系统架构种的管道-过滤器模式的话，所有操作都要做成同步的，对于网络购物这种大访问量的应用几乎是不可能的。所以，这种“重要不紧急”的场景很适合于使用事件总线模式。
