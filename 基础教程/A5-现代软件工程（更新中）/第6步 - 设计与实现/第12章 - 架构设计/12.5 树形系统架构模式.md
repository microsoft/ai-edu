
## 12.4 树形系统架构模式


### 12.4.1 主从模式（Master-Slave/Primary-Secondary）

因为 Slave 这个词比较敏感，因此英文中更多地使用 Primary-Secondary，我们只要知道 Slave 不是“奴隶”的意思就好。见图 12.4.1。

<img src='img/Slide15.svg'>

图 12.4.1 主从模式

#### 架构模式

这种模式由两部分组成：主节点和从节点。主节点将工作分配给不同的从节点，并根据从节点返回的结果计算最终结果。图 12.4.1 右侧显示了主从节点之间分配工作的顺序图，其中有一个硬性的要求：初始任务必须是可以**分割**的。

主从模式是分治（divide-and-conquer）原则的一个例子。每个从节点都是独立的，没有任何共享状态，因为它们是并行运行，或者是在同一个主机的不同进程中，或者是在不同的主机上，所以主从通信的延迟可能是一个问题。

### 优缺点

优点：

- 读写分离。
- 适合读多写少的场景，大并发读取时，多个从节点可以提供负载均衡。
- 从节点数量扩展灵活。
- 不怕数据丢失，有很多个备份。

缺点：

- 同步延迟问题，主从节点上的数据在某一时刻有可能不一致，不适合于要求一致性高的场合。
- 如果有大量写操作，会集中在主节点上。
- 主节点发生故障会比较麻烦，自动切换的复杂度高。

#### 应用场景

那么什么叫做可以分割？注意“分割”这个词比较生硬，它并非智能地“分解”，也非理性地“分析”。有几种应用：

- 并行计算：把一批数据或任务整齐地拆分成 N 份儿，然后分配给 N 个从节点去处理。比如大规模的并行计算时，可以把多个矩阵的运算分配给多个从节点并行完成，再在主节点中合并。
- 容错：主节点把同一个计算任务分配个多个从节点，然后从最快结束运算的从节点那里获得返回结果，并返回给调用者；或者是比较所有从节点的返回结果，取相似性最高的结果（三个结果是1.512，一个结果是1.511，则取1.512），返回给调用者。
- 提供准确度：不同的从节点执行同一个任务，但是它们各自的实现方式不同，比如，一个是用神经网络推理，一个用线性回归做预测，还有一个用表格匹配法取近似值，最终在主节点上用一种策略来决定最佳结果，如平均值或最多相似值。
- 数据库复制：主数据库被视为权威源数据库，从数据库与之同步。在有读取请求时，主数据库把请求转给从数据库，以提高并非读取的速度；在有写入请求时，只发生在主数据库上，然后再同步给从数据库。


### 12.4.2 代理模式 (Broker pattern)
#### 架构说明

代理模式用于在结构化系统中对组件解耦。系统内各组件间采用远过程调用（remote service invocations）的方式交互。代理（Broker）组件充当组件间通讯的协调角色。

提供服务的组件将其能力（服务以及特性）发布给代理，客户端均向代理请求服务，由代理将请求重定向到先前已发布过对应服务的组件进行处理。

使用场景
消息中间件软件：Apache ActiveMQ，Apache Kafka，RabbitMQ 与 JBoss 等等

#### 优缺点

优点：
- 通过一个代理对象完成一系列的处理，在将来的程序改动中，就会允许动态更改、添加、删除和重新定位对象，这使开发人员的发布变得透明，符合开闭原则。
- 代理模式能够协调调用者和被调用者，在一定程度上降低了系统的耦合度。
- 远程代理使得客户端可以访问在远程机器上的对象，远程机器可能具有更好的计算机性能与处理速度，可以快速响应并处理客户端请求。
- 代理模式在架构中还可以让虚拟代理通过使用一个小对象来代表一个大对象，可以减少系统资源的消耗，对系统进行优化并提高运行速度

缺点：

- 要求对服务描述进行标准化，我们要使用代理模式时则需要考虑异步处理机制、协议创建流程和错误环境控制，比较的繁琐。
- 由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。
- 实现代理模式需要额外的工作，有些代理模式的实现非常复杂。这些问题就造成了不易开发的弱点。


#### 应用场景

- 当客户端对象需要访问远程主机中的对象时可以使用远程代理。
- 当需要用一个消耗资源较少的对象来代表一个消耗资源较多的对象，从而降低系统开销、缩短运行时间时可以使用虚拟代理，例如一个对象需要很长时间才能完成加载时。
- 当需要为某一个被频繁访问的操作结果提供一个临时存储空间，以供多个客户端共享访问这些结果时可以使用缓冲代理。通过使用缓冲代理，系统无须在客户端每一次访问时都重新执行操作，只需直接从临时缓冲区获取操作结果即可。
- 当需要控制对一个对象的访问，为不同用户提供不同级别的访问权限时可以使用保护代理。
- 当需要为一个对象的访问（引用）提供一些额外的操作时可以使用智能引用代理。


#### 几种“代理”的区别

|英文|中文|解释|比喻|
|-|-|-|-|
|Agent|自主性代理|智能性较高，接收到 A 的请求，自主决定访问 B 还是访问 C，然后把 B 或 C 的返回结果告诉 A，但 A 并不知道 B 或 C 的存在||
|Broker|中介性代理|A 通过本代理得知 B 的存在，但是不知道如何访问 B，发送请求给代理，代理把该请求变成 B 可以听懂的语言发送给 B 并获得结果返回给 A|股票经纪人代买卖股票|
|Delegate|委托性代理|A 不知道怎么才能从 B 那里得到服务，甚至不知道 B 的存在，就把请求告诉代理，代理完成其它的任务|律师代理诉讼|
|Proxy|透传性代理|无智能，在 A 不能合法/有效地访问B时，把 A 的请求拿过来原封不动地传给 B，再把 B 的响应原封不动地回传给 A|传声筒|

### 12.4.3 事件总线模式 (Event-bus pattern)

#### 架构说明

事件总线模式应用于事件处理，主要由四个组件构成：事件源（event source），事件侦听者（event listener），通道（Channel）以及总线（event bus）。 事件源将消息发布到总线的特定通道，侦听者订阅相应的通道，事件源所发布的消息经通道通告给订阅通道的侦听者。

使用场景
Android 开发
通告（Notification）服务

#### 优缺点
事件驱动架构模式实现起来相对复杂，主要是由于它的异步和分布式特性。这可能会带来一些分布式的问题，比如远程处理的可用性，缺乏响应，broker重连等问题。

优点：

- 分布式的异步架构，事件处理器之间高度解耦，软件的扩展性好
- 适用性广，各种类型的项目都可以用
- 性能较好，因为事件的异步本质，软件不易产生堵塞
- 事件处理器可以独立地加载和卸载，容易部署

缺点：

- 涉及异步编程（要考虑远程通信、失去响应等情况），开发相对复杂
- 难以支持原子性操作，因为事件通过会涉及多个处理器，很难回滚
- 分布式和异步特性导致这个架构较难测试
- 模式分析

总体灵活性： 高
发布易用性： 高
可测试性： 低
性能： 高
规模扩展性： 高
开发容易度： 低

#### 应用场景
