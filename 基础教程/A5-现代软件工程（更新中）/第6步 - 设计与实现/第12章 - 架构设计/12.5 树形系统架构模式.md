
## 12.5 树形系统架构模式

### 12.5.1 代理模式 (Broker)

#### 几种“代理”的区别

本小节中描述的代理都是具备 **A$\leftrightarrow$代理$\leftrightarrow$B 三个角色**的，其中，代理帮助 A 完成访问 B 的任务，但形式上有细微差别，见表 12.5.1 和图 12.5.1。

表 12.5.1 几种“代理”的区别

|英文|中文/性质|解释|比喻|
|-|-|-|-|
|Agent|自主性代理<br>独立主体<br>有独立决策能力|A 不知道 B 或 C 的存在。<br>代理接收到 A 的请求，自主决定访问 B 还是访问 C，然后把返回结果告诉 A。|各国驻联合国代表；<br>保险公司的代理代表<br>保险公司的利益|
|Broker|中介性代理<br>独立主体<br>无自主决策<br>能力|B 在代理注册，A 通过代理得知 B 的存在，但不知道如何访问 B。<br>A 发送请求给代理，代理把该请求变成 B 可以听懂的语言发送给 B 并获得结果返回给 A|股票经纪人；<br>保险代理代表客户的<br>利益；<br>各类专卖店|
|Proxy|透传性代理<br>非独立主体|A 知道 B 的存在，但不能直接访问 B。<br>代理把 A 的请求原封不动地传给 B，再把 B 的响应原封不动地回传给 A。|语言翻译；<br>代理服务器|

还有一种叫做 Delegate 即“委托性代理”的概念，它只涉及两个方面的角色，即委托人和被委托人，没有第三方，所以不符合本节中的“代理”概念。

<img src='img/Slide20.svg'>

图 12.5.1 代理模式

#### 架构说明

在复杂系统中经常遇到的情况是，服务器可能暂时不能用，或者是有比以前更多的服务器可用，但是客户端并不知道。所有有必要增加一个中间代理来解决这个问题。见图 12.5.1。

该模式由三部分组成：

- 服务器，提供服务，并向代理注册，以便让客户端知道自己的调用方法或者访问位置。
- 代理，保持注册信息，当客户端的请求到达时，根据注册信息访问服务器，并把结果传回客户端。
- 客户端，向代理发出服务请求。

代理模式用于在结构化系统中对组件解耦。系统内各组件间采用远过程调用（remote service invocations）的方式交互。代理（Broker）组件充当组件间通讯的协调角色。服务器将其能力（服务以及特性）发布（注册）给代理，客户端均向代理请求服务，由代理将请求重定向到先前已发布过对应服务的服务器进行处理。

以上是 Broker（中介性代理）的典型行为。对于 Agent 和 Proxy 代理有一些例外情况：服务器不需要向代理注册，代理预先知道服务器的能力和访问地址。

对于 Broker 模式，客户端很可能存在一个 proxy API，客户端软件在本地调用这个 proxy API 提供的方法，这个 proxy API 负责访问远程的 Broker 或服务器来完成服务请求。这就简化了客户端的开发复杂度，通信过程由 proxy API 来完成。

#### 应用场景

局域网中的计算机都没有公网的 IP 地址，所以必须通过代理服务器访问互联网上的任何主机。而通过代理即使能访问很多国内网站了，但是有些国外的网站无法访问，这样就必须通过一个特殊的网关去访问，也叫做代理。需要在客户端做配置，指明代理服务器的地址。

以上情况中，服务器只能知道代理的存在，而不知道真正的客户端是谁，这叫做正向代理。下面的情况正相反：请求来源很明确，但是不知道是哪个服务器来响应。比如 Nginx 服务器把客户端的请求按照一定的规则发送给后端的诸多服务器之一处理，而客户端不需要任何特殊配置。这叫做反向代理，它代理的是服务器端。负载均衡就是一种反向代理。

图 12.5.1 右侧的流程实例中，有两种方式：

初始化：

1. 服务器 1 向代理注册（也可能不需要注册，适用于 Agent 和 Proxy 模式）；
2. 服务器 2 向代理注册（适用于 Broker 模式）。


方式一（直连）：

1. 客户端发起请求 1；
2. 代理告诉客户端服务器 1 的地址；
3. 客户端直接发请求给服务器 1；
4. 服务器 1 返回结果 1 给客户端。

DNS 就属于第一种方式，但是并不是典型的代理模式。

方式二（转发）：

1. 客户端发起服务请求 2；
2. 代理把服务请求 2 转发给服务器 2；
3. 服务器 2 返回结果 2 给代理；
4. 代理把结果 2 转发给客户端。

这是典型的代理模式的行为。

#### 优缺点

优点：
- 允许动态更改、添加、删除和重新定位服务，符合开闭原则。
- 在一定程度上降低了系统的耦合度。
- 可以增加额外的保护措施来做权限分级和保护服务器。

缺点：

- 要求对服务描述进行标准化，使用代理模式时则需要考虑异步处理机制、协议创建流程和错误环境控制，比较的繁琐。
- 可能会造成请求的处理速度变慢，甚至带来通信瓶颈。
- 实现代理模式需要额外的或重复的工作，不易开发。


### 12.5.2 事件驱动模式 (Event-Driven)

#### 架构说明

事件驱动模式应用于事件处理，主要由四个组件构成：事件源（event source），事件侦听者（event listener），通道（Channel）以及事件总线（event bus）。 事件源将消息发布到总线的特定通道，侦听者订阅相应的通道，事件源所发布的消息经通道通告给订阅通道的侦听者。

见图 12.5.2 拓扑结构。

<img src='img/Slide21.svg'>

图 12.5.2 事件驱动模式

一个事件源一般只发送消息到一个通道中，该通道一般由消息队列实现。而监听者根据业务需求可以监听一个或多个通道内的消息，比如图 12.5.2 中的监听者 1 就同时监听通道 1 和通道 2 的消息，此时，事件源 2 要发送两个消息拷贝到通道 2 中。

发布-订阅模式是事件驱动模式的一个子集。

#### 应用场景

这里用一个网络购物的应用常见来说明事件驱动的应用方式，见图 12.5.2 右侧订单服务实力。

1. 一个网络购物的用户下了订单，应用程序会发送“订单事件”到事件总线；
2. “订单处理”模块会得到“订单处理通知”，处理订单，比如核对存货量、配送地、付款信息等；
3. 处理完毕后发送“订单确认事件”到事件总线；
4. “订单确认”模块会得到“订单确认通知”，给用户发送确认短信或使用其他通信手段；
5. 发送消息给用户；
6. 发送完毕后发送“通知成功事件”到事件总线；
7. “订单执行”模块会得到“订单配送通知”；
8. 商家配送，送货上门，用户签收；
9. 配送完成后发送“订单完成事件”到事件总线。
10. (未画出）系统发送“用户评价通知”然后关闭该订单。

这种应用场景相当复杂，如果用串行系统架构种的管道-过滤器模式的话，所有操作都要做成同步的，对于网络购物这种大访问量的应用几乎是不可能的。所以，这种“重要不紧急”的场景很适合于使用事件驱动模式。


#### 优缺点

优点：

- 分布式的异步架构，事件处理器之间高度解耦，软件的扩展性好。
- 适用性广，各种类型的项目都可以用。
- 性能较好，因为事件的异步本质，软件不易产生堵塞。
- 事件处理器可以独立地加载和卸载，容易部署。

缺点：

- 涉及异步编程（要考虑远程通信、失去响应等情况），开发相对复杂。
- 难以支持原子性操作，因为事件通过会涉及多个处理器，很难回滚。
- 分布式和异步特性导致这个架构较难测试。


### 12.5.3 微服务模式（Microservices）

当你将应用程序作为一组微服务编写时，实际上就是在编写可以协同工作的多个应用程序。其中每个微服务都有自己的职责，团队可以独立于其他微服务进行开发。这些微服务之间唯一的依赖就是通信。当微服务彼此通信时，你必须确保它们之间发送的消息能够向后兼容。
优点：

可以分别编写，维护和部署每个微服务
易于扩展，因为你可以仅扩展需要扩展的微服务
更新迭代应用程序的各个部分比较容易，因为它们较小，并且与其他部分的耦合较少
团队成员能快速响应且富有成效
高度可维护和可测试–微服务模式满足快速频繁的开发和部署
可独立部署–无需与其他团队协调即可部署其服务

应用场景：

小型网站
边界明确的企业数据中心
快速发展的业务
多部门协作的开发团队

### 12.5.4 插件模式（Plug-in）

微内核架构模式也称为插件模式。这种模式允许你将其他应用程序功能作为插件添加到核心应用程序，从而提供可扩展性以及功能分离。
微内核架构模式由两种类型的架构组件组成：核心系统和插件模块。

插件模块，提供应用程序功能和自定义处理逻辑的可扩展性，灵活性和隔离性。
传统上，微内核架构模式的核心系统仅包含使系统运行所需的最小功能。

微内核架构模式的最佳示例是Eclipse IDE。下载基本的Eclipse产品为你提供的只是一个编辑器功能。但是，一旦开始添加插件，它就会成为高度可定制和有用的产品。
优点：

极大的灵活性和可扩展性
一些插件允许在应用程序运行时添加
良好的便携性
易于部署
能够快速响应不断变化的环境
插件模块可以单独进行测试。
高性能，因为你可以自定义和简化应用程序以仅包括所需的那些功能。
应用场景


从不同来源获取数据，转换数据并将其输出到不同地方的应用程序
工作流应用程序
任务类应用程序


VSCode 组成结构
VSCode 是基于 Electron 构建的，主要由三部分构成：

Electron: UI
Monaco Editor
Extension Host
Language Server Protocol & Debug Adapter Protocol

VSCode 中的大部分功能都是通过 Extension Host 来实现的。符合 LSP 的插件对应的高亮等语言特性就会反映到 Monaco Editor 上。从源码的 extensions 目录中可以看到，VSCode 默认集成了各种语言的插件。

Monaco Editor
是一个基于网页的编辑器，有符合 LSP 的插件就可以进行高亮、悬停提示，导航到定义、自动补全、格式化等功能。它的代码位于 monaco-editor

Extension Host
VSCode 的主进程和插件进程是分开管理的，Extension Host 就是用来管理插件进程的。

Extension Host 是用来确保插件：

不影响启动速度
不会减低 UI 响应速度
不会改变 UI 样式
因此保证 VSCode 的稳定和快速的密码就在于使用 Extension Host 将主进程和插件进程分开，使插件不会影响到 VSCode 主进程的性能和稳定。

在编写插件的时候 VSCode 可以让插件设置 Activation Events 来对插件懒加载。比如只有打开了 Markdown 文件才打开对应的插件。这样可以降低无谓的 CPU 和内存使用。

Language Server Protocol & Debug Adapter Protocol
这两个协议主要是为了将编辑器和编程语言/调试服务的功能分离开，实现任何语言只要编写对应的语言服务即可。目前各大编辑器都已经支持了这个协议。
