
## 12.5 环形系统的架构模式

### 12.5.1 MVC 模式

MVC 这个名词很多读者都熟悉，它代表了 Model-View-Controller。但大多数人熟悉的应该是 MVC 框架和设计模型，我们这里要讲解的是 MVC 架构模型。表 12.5.1 举例说明了三者的区别。

表 12.5.1 三种概念的举例比较

|MVC|基本功能|MVC架构举例|MVC框架举例|MVC设计举例|
|-|-|-|-|-|
|模型|数据或状态的表示，应用逻辑的封装。<br>如：游戏卡带。|管理电子邮件系统<br>的所有数据|JAVA: JavaBean<br>ASP.NET: 用户自定义类|封装对象：<br>文件、<br>文件列表|
|视图|用户界面组件，模<br>型数据的可视化，<br>允许用户输入。<br>如：游戏手柄和电视。|Web网站可以同时<br>提供浏览器页面和<br>手机WAP页面来收<br>发电子邮件|JAVA: JSP<br>ASP.NET: Razor|控件绑定：<br>大图标、列表、<br>小图标、详情|
|控制器|选择模型和视图，将<br>用户的操作转换为对<br>模型或者视图的更改<br>如：游戏主机。|根据请求类型决定<br>是浏览邮件还是发<br>送邮件，选择不同<br>模型，并确定视图|JAVA: Servlet<br>ASP.NET: Controller|用户操作：<br>剪切、复制、<br>更名、删除、<br>排序、新建|
|说明|通用功能定义，<br>以游戏机为例|以电子邮件系统为例|以Java和<br>ASP.NET为例|以 Windows 的<br>文件管理器为例|

#### 架构说明

见图 12.5.1。

<img src='img/Slide18.svg'>

图 12.5.1 MVC 架构

MVC 模式将交互式应用程序拆分为三个部分：

- 模型（model）：包含业务功能及数据、状态。
- 视图（view）：把模型中的数据信息用指定的界面展示给用户，通常有多个视图可供控制器选择。
- 控制器（controller）：处理用户的输入操作，选择模型和相应的视图。

MVC 模式通过将内部信息表示、用户信息呈现以及用户操作接收分开的方式解耦组件，实现高效的架构重用。

以老式插卡游戏机为例：

- 游戏主机是控制器 C。注意这里的“控制”不是指用户的操作，而是对各个零部件的控制。它接收手柄的操作信号，把模型中指定的视图播放到显示器上。
- 游戏卡是模型 M，封装了游戏的数据和逻辑，和其它两个部件完全无关，可以任意更换游戏卡，只要接口一致即可。它决定显示器上的图像。
- 游戏手柄和显示器是视图 V。注意，手柄是用户交互设备，所以属于视图，而不是属于控制器。

#### 优缺点

优点：
1. 耦合性低
视图层和业务层分离，这样就允许更改视图层代码而不用重新编译模型和控制器代码，同样，一个应用的业务流程或者业务规则的改变只需要改动MVC的模型层即可。因为模型与控制器和视图相分离，所以很容易改变应用程序的数据层和业务规则。
2. 重用性高
MVC模式允许使用各种不同样式的视图来访问同一个服务器端的代码，因为多个视图能共享一个模型，它包括任何WEB（HTTP）浏览器或者无线浏览器（WAP），比如，用户可以通过电脑也可通过手机来订购某样产品，虽然订购的方式不一样，但处理订购产品的方式是一样的。由于模型返回的数据没有进行格式化，所以同样的构件能被不同的界面使用。
3. 部署快，生命周期成本低
MVC使开发和维护用户接口的技术含量降低。使用MVC模式使开发时间得到相当大的缩减，后端开发人员集中精力于业务逻辑，界面程序员集中精力于表现形式上。
4. 可维护性高
分离视图层和业务逻辑层也使得 WEB 应用更易于维护和修改

缺点：

1. 完全理解MVC比较复杂。
   完全理解并掌握 MVC 不是一个很容易的过程。
2. 调试困难。
   因为模型和视图要严格的分离，这样也给调试应用程序带来了一定的困难，每个构件在使用之前都需要经过彻底的测试。
3. 不适合小型，中等规模的应用程序
   在一个中小型的应用程序中，强制性的使用 MVC 进行开发，往往会花费大量时间，并且不能体现 MVC 的优势，同时会使开发变得繁琐。
4. 增加系统结构和实现的复杂性
   对于简单的界面，严格遵循 MVC，使模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率。
5. 视图与控制器间的过于紧密的连接并且降低了视图对模型数据的访问
   视图与控制器是相互分离，但却是联系紧密的部件，视图没有控制器的存在，其应用是很有限的，反之亦然，这样就妨碍了他们的独立重用。
   依据模型操作接口的不同，视图可能需要多次调用才能获得足够的显示数据。对未变化数据的不必要的频繁访问，也将损害操作性能。


#### 应用场景

一般用于主流开发语言所构建的互联网网页应用架构，比如 ASP.NET MVC、Spring MVC。

在图 12.5.1 右侧显示了 ASP.NET MVC 框架的工作流程：

1. 用户浏览器向 Web Application 提出请求 URL（如：https://xxx.com/home/index）；
2. Routing Module 执行 RouteTable 中定义的路由动作；
3. MVCHandler 生成 home_Controller；
4. 执行 URL 中的 index_action，向 Model 请求数据；
5. Model 从数据库中获得数据；
6. Controller 决定使用哪个 View；
7. 把 Model 交给 View；
8. 合成好网页后返回给用户浏览器。

读者可以很容易地找到 Spring MVC 框架的工作流程自行阅读，相信会有所帮助，在此不再赘述。

### 12.5.2 黑板模式（Black Board）

#### 架构说明

#### 优缺点

#### 应用场景

一、定义

黑板模式是一种常用的架构模式，应用中的多种不同数据处理逻辑相互影响和协同来完成数据分析处理。黑板模式允许多个消息读写者同时存在，消息的生产者和消费者完全分开。这就像一个黑板，任何一个教授（消息的生产者）都可以在其上书写消息，任何一个学生（消息的消费者）都可以从黑板上读取消息，两者在空间和时间上可以解耦，并且互不干扰。这种模式对于没有确定解决方案策略的问题是有用的。

二、模式组成

黑板模式由3个主要组成部分组成。

(1)知识源：包含独立的、与应用程序相关的知识，知识源之间不直接进行通讯，它们之间的交互只通过黑板来完成。

(2)黑板数据结构：按照与应用程序相关的层次来组织并解决问题的数据，知识源通过不断地改变黑板数据来解决问题。

(3)控制组件；完全由黑板的状态驱动，黑板状态的改变决定了需要使用的特定知识。

黑板模式一般不会对架构产生什么影响，但它通常会要求有一个清晰的消息结构。黑板模式一般都会提供一系列的过滤器，以便消息的消费者不再接触到与自己无关的消息。在实际开发中，黑板模式常见的有两种实现方式：

（一）数据库作为黑板

利用数据库充当黑板，生产者更新数据信息，不同的消费者共享数据库中信息，这是最常见的实现方式。该方式在技术上容易实现，开发量较少，熟悉度较高。缺点是在大量消息和高频率访问的情况下，性能会受到一定影响。在该模式下，消息的读取是通过消费者主动“拉取”，因此该模式也叫做“拉模式”。

（二）以语音识别为例：

语音识别黑板里边就是语言包 ；语言包就是知识源，控制机构就是管理语言包的，当你说一句话，不知道是什么语言，所以时非确定性的问题，控制机构把你说的话对应的语言包给你看，这就是黑板模式的流程

所有的组件都可以访问黑板。组件可以生成添加到黑板上的新数据对象。组件在黑板上查找特定类型的数据，并通过与现有知识源的模式匹配来查找这些数据。

三、模式实现

（一）利用数据库

利用数据库充当黑板，不同的应用共享数据库中信息，并且可以更新数据信息。这也是最常见的实现方式。

（二）利用发布—订阅模式

这种实现方式通常采用消息队列作为黑板，队列工作在主题模式（Topic），专家作为队列的订阅者，同时可以向队列发送消息，消息会被发送至所有订阅者。以上过程实现了专家间的信息交流。

四、影响黑板系统的因素

影响黑板系统设计的最大因素是引用问题本身的特性，但是支撑应用程序的黑板体系结构有许多相似的特征和构件。对于特定应用问题，黑板系统可通过选取各种黑板、知识源和控制模块的构件来设计；也可以利用预先制定的黑板体系结构的编程环境。

五、应用实例

黑板系统的典型应用是信号处理领域，如网络信息检索、电子商务、自动控制、商业管理智能决策、语音和模式识别、智能控制领域等

实际应用

在实际应用中常见的实现模式有：

A 利用数据库

利用数据库充当黑板，不同的应用共享数据库中信息，并且可以更新数据信息。这也是最常见的实现方式。

特点：

1 便于实现信息的查询，筛选和统计，这方面关系数据库提供了SQL 92的强大支持。

2 不能用于较高实时性要求的环境，这种实现是工作在“拉模式”下的，并且高频率的访问数据库会导致严重的系统性能问题。

B 利用发布—订阅模式

这种实现方式通常采用消息队列作为黑板，队列工作在主题模式（Topic），专家作为队列的订阅者，同时可以向队列发送消息，消息会被发送至所有订阅者。以上过程实现了专家间的信息交流。

特点：

1、可以有效应用于实时性要求较高的系统，这种实现工作在“推模式”下。

2、难于实现信息的统计分析，不像实现方式一那样可以通过SQL支持，这些工作必须开发者自己完成。

六、优缺点分析

优点：可用于非确定性问题求解，启发式解决过程，可维护性，可重用

缺点：不能确保期望结果，效率低下，回退，不支持并行，共享空间的访问需要同步

### 12.5.3 解释器模式

#### 架构说明

#### 优缺点

#### 应用场景
