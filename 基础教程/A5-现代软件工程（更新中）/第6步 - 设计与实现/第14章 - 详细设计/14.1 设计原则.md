## 14.2 设计原则

这一节的内容都是一些经典的知识，熟悉的读者可以跳过。

在架构设计、概要设计中，我们常说要注意子系统/模块划分时高内聚低耦合，其实对于详细设计也是如此，而且由于有代码和数据结构的存在，从而会体现得更具体。

<img src="img/Slide3.SVG"/>

图 14.2.1 内聚与耦合

图 14.2.1 展示了内聚与耦合，右侧为推荐，左侧为不推荐。

### 14.2.1 模块内部的内聚

内聚是模块功能强度的度量，即模块内部各个元素彼此结合的紧密程度。一个模块内部各元素之间的紧密程度越高，则其内聚性越高，模块独立性越好。模块功能越单一，内聚性就越高，模块的独立性就越强。一个模块应该做好一个功能就可以了，不要面面俱到，不然难以维护。

需要说明的一点是，不同程度的内聚之间并非是线性关系的。上面的所有内聚类型中，偶然内聚和逻辑内聚是非常糟糕的内聚，而其它内聚都不错。只不过在不错之中，它们又能分出个高下。

以下按内聚性由低（不推荐）到高（推荐）排列。

#### 1. 偶然内聚

指一个模块内的各个函数或数据之间没有任何联系。

举例：把一推不相关的代码都生硬地组合在一个类里。
```
add(int a, int b)  # 加法
split(str a, int b)  # 拆分字符串
```

可以想象成一群人在火车站大厅里候车，每个人的出行都是偶然的，大家互相也不认识，各做各事，所以叫做**偶然内聚**。

#### 2. 逻辑内聚

指模块内执行若干个逻辑上相似的功能，通过参数确定该模块完成哪一个功能。

举例：有多个加法运算代码块，分别处理参数为 int 或 float 或 double等。这些代码块之所以聚在一起，只是它们都是为了完成加法运算而已。

```
add(int a, int b)  # 整数加法
add(float a, float b)  # 浮点数加法
add(double a, double b)  # 双精度浮点数加法
```

可以想象成在候车大厅里的一部分人登上了同一趟列车，**逻辑**上正是因为他们的出发点和目的地相同，所以都汇聚在车厢里。但笔者认为这一条应该是**空间内聚**。

#### 3. 时间内聚

指把需要同时执行的动作组合在一起形成的模块。

举例：类似于利用抽象工厂模式生成一碗粥，你可以先放水，也可以先放米，这两个动作之间没有必然的顺序，但为了生成一碗粥，需要同时执行这两个动作。

```
a = create_thread(A)  # 创建线程 a, 执行对象 A 的逻辑
b = create_thread(B)  # 创建线程 b, 执行对象 B 的逻辑
thread.join(a, b)  # 等着二者都执行完毕

def A():  # A 的逻辑
   ... # 处理数据

def B():  # B 的逻辑
   ... # 调用外部系统的 API 完成权限认证
```

可以想象成在中午时段，旅客中有些人不想吃泡面，就跑到餐车去吃饭，有几个散客还不得不拼桌吃饭。这个时段就是**时间内聚**。

#### 4. 过程内聚

指一个模块完成多个任务，这些任务必须按照指定的过程执行。

举例：类似操纵数据库。你需要先获得connection对象，然后才能创建statement对象，最后才能执行sql语句。

```
connection = db.get_connection()
sql = statement(...)
connection.exec(sql)

def db():  # db 类
    ...

def statement():  # statement 类
    ...

def connection():  # connection 类
    ....
```

可以想象成列车员推着小餐车卖盒饭，有一个旅客要买，列车员递给他盒饭，并等他扫码付费，然后旅客要求列车员开发票，列车员记录下座位号，1 小时后送来发票。旅客-列车员实际上产生了**过程内聚**。

#### 5. 通信内聚

指模块内的所有处理函数都在同一个数据结构上操作，或者各处理使用相同的输入数据或者产生相同的输出数据。

举例：有一个三个字段的数据结构数组，第一个函数只处理所有记录的第一个字段，第二个函数只处理所有记录的第二个字段，......，三个函数分别调用完毕后，这个数组才被处理完毕，模块完成处理功能。

可以想象成有些人没有吃饭，到了下午 2 点忽然觉得饿了，于是拿出手机来扫码购买盒饭。在供餐系统中，已经有 20 多位旅客交款后排队等候了，这些旅客在供餐系统的虚拟空间中产生了**通信内聚**。

#### 6. 顺序内聚

指一个模块中的各个函数都密切相关，并且函数必须顺序执行，前一函数的输出就是下一函数的输入。

举例：处理一批原始数据，先去掉含有非法数值的记录，紧接着针对某些字段做加和求平均值的处理并只保留结果字段，然后对该结果字段进行方差统计，最后给出分析结果。这一系列处理方法和顺序都是该针对该数据的特定流程，无法拆开或者复用于其它数据。

可以想象成旅客们吃饱喝足，睡了一会儿，感觉内急，于是纷纷起身去上厕所。但是厕所只允许一次一人使用，所以大家就在门口排队等候，于是产生了**顺序内聚**。

#### 7. 功能内聚

指模块内的所有函数共同作用完成一个功能，缺一不可。

举例：定义一个人的属性，如身高、体重、性别、种族、学历、身份证号码、籍贯、政治面貌等等，必须要全面，不能有遗漏，否则此人就无法被正确描述，或者和其它人混淆。然后还要描述此人的各种相貌特征、行为特征、心理特征等等。

可以想象成在解决内急后，有的旅客提出要打扑克，征得前排旅客的同意后，大家把座椅调整成面对面的，就一起愉快地玩儿起来。这时产生了**功能内聚**。

### 14.2.2 模块之间的耦合

耦合性(Coupling)，也叫耦合度，是对模块间关联程度的度量。其耦合性越强，同时表明其独立性越差。模块之间联系少，耦合性就越低，模块之间的相对独立性就越强。模块应该管理好自己的事情就可以了，这样即不会太复杂，也便于专注的完成自己的事情。

对于耦合，如果模块间必须存在耦合，应尽量使用数据耦合，少用控制耦合，限制使用公共耦合的范围，坚决避免使用内容耦合。

以下按耦合性由高（不推荐）到低（推荐）排列。

#### 1. 内容耦合

- A 访问 B 的内部数据。
- A 不通过正常接口而转到 B 的内部逻辑。
- A 和 B 有逻辑、代码重叠（只可能出现在汇编程序中）。
- 一个模块有多个入口（即该模块有多个功能）。

绝对避免使用内容耦合。目前的高级程序设计语言已经不允许有上面列表中第二种和第三种内容耦合形式了，但是第一种和第四种还需要程序员来避免。

#### 2. 公共环境耦合

两个或多个模块通过一个公共数据环境相互作用时，称为公共环境耦合。又可以分为两种情况：

- A 向环境中写数据，B 从环境中读数据。实际上是数据耦合的一种，属于松散耦合。
- A 和/或 B 既要写数据，也要读数据。实际上是控制耦合的一种，属于紧密耦合。

在实践中，通常使用 Linux 的公共环境来传递参数。但是这个环境谁都可以读写，所以非常不安全，除非这个环境中只有你自己的应用程序在运行。

#### 3. 外部耦合

模块间通过全局变量互相协作。

比如：模块 A 和模块 B 通过全局变量 status 来决定自己的行为。
```
global status = 1  # 可选 1,2,3

model A():
    if status == 1:
        status = 2

model B():
    if status == 2:
        status = 3
```

#### 4. 控制耦合

如果 A 和 B 之间传递的信息中有控制信息，称为控制耦合。它属于中等程度的耦合，增加了系统的复杂程度。

指一个模块调用另一个模块时，传递的是控制变量，被调用模块通过该控制变量的值有选择地执行模块内的某一功能。因此，被调用模块应具有多个功能，哪个功能起作用受调用模块控制。

```
def foo(a, b, flag):
    if flag:
        return a + b
    else:
        return a * b

bool flag = True  # 逻辑控制变量
result = foo(3.4, 1.5, flag)
```

#### 5. 标记耦合

指两个模块之间传递的是数据结构。

Python 中经常使用的 kwargs 参数实际上就是一个字典数据结构，比如：
```
kwargs = {"kernel":(3, 3), "stride":(1, 1), "padding": (0, 0)}
convolution(data, kwargs)
```

#### 6. 数据耦合

如果两个模块通过参数交换信息，但是交换的信息仅仅是数据，则成为数据耦合。属于松散耦合。

比如：

- 模块 A 生成了一个文件，把文件的地址告诉模块 B，模块 B 使用该文件做后续处理。常见于技术架构中的管道-过滤器模式。
- 模块 A 在内存中生成了一段数据结构，然后把数据结构指针告诉模块 B。
- 模块 A 只是把一个字符串（比如某个机器的名字或 IP 地址）告诉模块 B。



#### 7. 无直接耦合

指两个模块之间没有直接的关系，它们分别从属于不同模块的控制与调用，它们之间不传递任何消息。

```
model A(input):
    return result_A

model B(input):
    return result_B

main:
    input = 1
    result_A = A(input)
    result_B = B(result_A)
```
模块 A 和 B 互相不知道，通过主控过程 main 来先后调用它们，把 A 的结果输入 B，当然也有可能不到用 B 而调用其它模块。

### 14.2.3 七个设计原则

本节的内容是软件领域著名的七大设计原则，是原有的 SOLID 法则再加上合成复用原则形成的。

|原则|说明|目的|
|-|-|-|-|
|开放封闭原则|扩展新功能时，不修改原有的代码|可扩展|
|里氏替换原则|继承要合规，不要重写父类的方法|少出错|
|接口隔离原则|接口只提供充分必要的功能定义|高内聚|
|单一职责原则|一个类只提供一组类似的功能|高内聚|
|最少知识原则|只与关系密切的类通信|低耦合|
|依赖倒置原则|针对接口编程，不要对实现编程|低耦合|
|合成复用原则|复用时先考虑组合/聚合，再考虑继承|低耦合|

#### 1. 开放封闭原则

OCP - Open Closed Principle。勃兰特·梅耶在 1988 年的《面向对象软件构造》一书中提出。

- 原始定义
  软件实体应该对扩展开放，对修改关闭。

- 核心思想
  当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。

- 实现方法
  通过接口或抽象类或虚方法为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现（子）类中。

- 设计举例
  有两个运算符 +,-，现在要新增加乘法，如何不改变原有代码？


要点：
1. 定义父类 Operator 表示通用运算符。
   其中：
   - 定义两个运算变量 number_A 和 number_B，可供子类使用。
   - 定义一个虚方法 Compute()，实现虚拟运算。
2. 定义子类，包括：
   - 加法 AddOperator，在 Compute() 中实现加法。
   - 减法 SubOperator，在 Compute() 中实现减法。
3. 定义一个简单工厂类 OperatorFactory，输入运算符类型调用 createOperator() 方法来创建
4. 新增加一个乘法或者任何其它运算符：
   - 增加 NewOperator 类文件；
   - 实现自己的 Compute() 方法；
   - 在 OperatorFactory 中注册此新运算符，即可完成调用新运算符进行运算的功能。

注意，在 OperatorFactory 中增加对新运算符的识别，并非修改，而是扩展。

#### 2. 里氏替换原则

LSP - Liskov Subtitution Principle。里斯科夫女士在 1987 年的面向对象技术高峰会议上提出。

- 原始定义
  继承必须确保超类所拥有的性质在子类中仍然成立。

- 核心思想
  不要破坏继承体系。它阐述了有关继承的一些原则，也就是什么时候应该使用继承，什么时候不应该使用继承，以及其中蕴含的原理。是继承复用的基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。

- 实现方法
  子类可以扩展父类的功能，但不能改变父类原有的功能。

- 代码举例
  这个原则比较简单，直白地说就是子承父业，父亲会的那些手艺，儿子都会并且不能走样儿。

```java
class A {  // A 是父类
    public int func1(int a, int b) {  // 有一个功能 func1 可以完成加法运算
        return a + b;
    }
}
class B extends A {  // B 继承 A
    public int func1(int a, int b) {  // 改写了父类的 func1，错误！
        return a * b;  // 改为完成乘法运算
    }
    public int func2(int a, int b) {  // 增加了属于子类自己的 func2，正确！
        return a * b;  // 完成乘法运算
    }
}
```
上面的代码中，A 类有一个功能 func1，在子类 B 中被修改了，这是错误的做法；正确的做法是子类实现自己的 func2 来扩充功能。当需要多态继承时，父类设置为抽象类（abstract func1），不实现任何功能即可在子类中任意覆盖。

有一个著名的生物学上的例子也经常被软件界拿出来说事儿：鸟儿都会飞，企鹅不会飞，但是企鹅是鸟儿。所以在软件上要把“飞翔”设计为一种能力（接口）而不是行为属性，这样企鹅依然可以继承自鸟儿，但是不实现“飞翔”接口即可。

#### 2. 最少知识原则

LoD - Law of Demeter。伊恩·荷兰于 1987 年美国东北大学的一个名为 Demeter 的研究项目中提出。Demeter 是拉丁语，特指古希腊的德墨忒尔女神，没有其它含义，所以翻译成“迪米特”应该是国内某位学者第一次引入这个名词时的个人意见。

- 原始定义
  只与你的直接朋友交谈，不和陌生人谈话。

- 核心思想
  减低耦合度。迪米特法则要求限制软件实体之间通信的宽度和深度，其目的是降低类之间的耦合度，提高模块的相对独立性。

- 实现方法
  如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。

- 代码举例
  在下述代码中，b1,b2,b3 都是 A 的朋友，可以直接通信。但是最后一行有效代码中，b3 通过 c1 调用了 C 的方法 func1，这是违反本原则的，但是可以通过 b3.func2() 来间接实现这一目的。当然，如果把 func1 设置为 private 也可以解决这个问题。
  如果 A 和 C 的关系很密切，可以直接在 A 中定义 C 为属性，这样就可以摆脱 B。这里并没有一个明确的指导方针，需要在实际应用场景中考虑是否这样做。

```java
class C {  // 对象 C
    public void func1() {...}
}
class B { // 对象 B
    C c1 = new C();  // c1 是 B 的属性
    void func2() {
        c1.func1();
    }
}
class A {  // 对象 A
    B b1 = new B();  // b1 是 A 的属性
    void func3(B b2) {...}  // b2 是 A 的 func3 方法的参数
    void func4() {
        B b3 = new B();     // 在 A 的 func4 方法中创建了 b3
        b3.c1.func1();      // !!! 直接调用 C 的 func1 违反了最少知识原则
        b3.func2();         // 可以通过调用 B 的 func2 来间接到达调用 C 的 func1 的目的
    }
}
```


#### 4. 接口隔离原则

Interface Segregation Principle。罗伯特·马丁在 90 年代提出的。

- 原始定义
  - 客户端不应该被迫依赖于它不使用的方法。
  - 一个类对另一个类的依赖应该建立在最小的接口上。

- 核心思想
  接口设计要精简。接口隔离原则是为了约束接口、降低类对接口的依赖性，提高类的内聚性、降低它们之间的耦合性，体现了封装的思想。

- 实现方法
  要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用，避免接口臃肿。

- 代码举例
  大学老师（Professor）有两个职责：教学，科研。假设老师 A 只负责教学，而老师 B 只负责科研，还有科研、教学俩手抓的老师 C。如何让老师 A 不必关心科研（research 方法），老师 B 不必关心教学（teach 方法）?

```java
// 科研接口
public interface Research {
    void research();
    void meeting();
}
// 教学接口
public interface Teach {
    void teach();
    void meeting();
}
// 大学教授同时继承两个接口并具体实现
public class Professor implements Teach, Research {
    @override
    public void teach() {}  // 教学
    @override
    public void research() {}  // 科研
    @override
    public void meeting() {}  // 开会
}
// 老师 A 不做科研，可以只有教学能力
public class Teacher {
    public static void main(){
        Teacher professor = new Professor();
        professor.teach()
        professor.meeting()
    }
}
// 老师 B 是专职研究员不做教学，可以只有科研能力
public class Researcher {
    public static void main(){
        Reseacher professor = new Professor();
        professor.research()
        professor.meeting()
    }
}
```

如此一来，普通老师可以只管讲课不管科研，而专职研究员可以只管科研不管讲课，不强迫，不依赖。但是显然这是一个理想主义的设计，现在的大学老师都两个职责都要履行。

#### 5. 依赖倒置原则

DIP - Dependence Inversion Principle。罗伯特·马丁 1996 年在 C++ Report 上发表的文章。

- 原始定义
  高层模块不应该依赖底层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。

- 核心思想
  面向接口编程。在软件设计中，细节具有多变性，而抽象层则相对稳定，因此以抽象为基础搭建起来的架构要比以细节为基础搭建起来的架构要稳定得多。

- 实现方法
  要面向接口编程，不要面向实现编程。降低类间耦合，提高系统稳定性，减少并行开发引起的风险。



#### 6. 单一职责原则

SRP - Single Responsibility Principle。罗伯特·马丁于 2003 年在《敏捷软件开发：原则、模式和实践》一书中提出的。

- 原始定义
  单一职责原则规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分。

- 核心思想
  一个类只负责一项职责。设计简单，控制类的粒度大小，将对象解耦，提高其内聚性。

- 实现方法
  发现类的不同职责并将其分离，再封装到不同的类或模块中。而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。

- 设计举例
  智能手机在工业界是一个非常成功的例子，小巧、通用、功能强大。但是在软件界，它却是一个被经常拿出来鞭挞的例子。

  左侧是手机的现状：它除了有基本的内存、硬盘、CPU、屏幕、电池等零件外，还具有一大堆的功能：基本的如充电、上网、电话，音频录制和音乐播放，视频录制和播放、文本阅读、玩游戏，等等。这在软件设计上就违背了单一职责原则。

  但是，手机这种设备本来就不是单一功能的（如照相机、摄影机、录音机等专业）设备，所以也可以说它实现了电话接口、视频接口、声音接口、应用软件接口，是一个复合体，而这些接口的职责都是单一的。





#### 7. 合成复用原则

CRP - Composite Reuse Principle。

- 原始定义
  软件复用时，尽量先使用组合/聚合关系来实现，其次才考虑使用继承关系来实现。

- 核心思想
  少认领爸爸，多依靠兄弟。

- 实现方法
  通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。

- 设计举例
  手机。见单一职责原则。
