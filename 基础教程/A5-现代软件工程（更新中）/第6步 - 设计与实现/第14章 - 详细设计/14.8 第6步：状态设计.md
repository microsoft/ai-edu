
## 14.8 状态设计

### 14.8.1 控制中心的状态转换

在数据流图中定义了一系列大的流程，在功能设计中划分了模块，但是都没有给出所有的分支和细节，所以我们在这一小节要通过对控制中心的状态转换设计来捋清楚所有细节。绘制传统的流程图也是可以做到这一点的，但是不包含状态名称信息，在后面的文档或者开发过程中，不容易形成共同语言。而且使用流程图做设计，实现时只能用 if...else 来编写代码，当一个对象状态非常复杂时，用 if...else 解决不了问题。

<img src="img/Slide18.SVG"/>

图 14.8.1 - 控制中心状态设计


状态解释如下：

1. 初始状态，手工启动控制中心的程序，进入“已启动”状态；
2. 用户上传数据，完毕后会通知控制中心，进入“已上传”状态；
3. 自动检测数据，如果合格，就启动训练，进入“训练中”状态；如果不合格，就终止；
4. 训练完毕后进入“已训练”状态；
5. 检查训练结果，即新的数据模型是否优于旧的模型，合格的话使用新模型进入预测，不合格的话使用旧模型进入预测；进入“预测中”状态；
6. 预测完毕，进入“已预测”状态；
7. 检查预测结果，如合格就发布结果，进入“已发布”状态；如果不合格，就“终止”；
8. 发布完毕后，进入“终止”状态。

其中，“启动控制中心”和“退出控制中心”都是手动完成的，不需要编码。

控制中心提供 REST API 以便得到外部通知，再对内进行任务调度。图 14.8.1 的各状态之间的转换还算比较规矩（顺序性较强），基本没有乱跳的，所以后续的开发人员在编码实现时，用 if...else 来实现呢，还是用状态机模型来实现呢？这依赖于在业务逻辑中有没有异步或者阻塞情况发生。

比如，“已预测”状态后，会有一个事件（在状态设计中叫做事件，在功能设计中叫做模块）叫做“检查预测结果”，如何检查不是状态设计要关心的问题，在具体运行中，有可能是手工检查（这就需要中断流程，并在控制中心提供一个界面来人工检查预测结果数据），也可能是自动检查（通过一段代码来判断输出结果是否符合要求）。

如果是人工检查的话，那就是一个异步过程：

1. 预测完毕，输出预测结果到文本文件存储；
2. 系统生成一封电子邮件，发送给当事人；这一步已经脱离了本系统的控制。
3. 邮件里面带着一个链接，点击链接将会从控制中心得到一个网页，来浏览预测结果文件的文本内容；
4. 网页最下端有一个“合格”按钮和一个“不合格”按钮，用于通知控制中心，是继续后面的流程，还是就此终断。这一步又把控制权返回给系统。

还有一种设计方式是，当文本文件的内容不多时，可以放到邮件正文或附件中，并在邮件正文中附带一个链接，导航到控制中心的一个简单网页上，再选择“合格”或“不合格”。

### 14.8.2 虚拟机状态设计

由于系统都运行在 Azure 上，而且定制化程度较高，所以我们都使用 Azure 上的虚拟机来搭建控制中心、训练子系统、预测子系统。

由于虚拟机的收费较高，所以要研究清楚虚拟机的收费策略，即：
- 需要申请虚拟机，虚拟机自动启动；
- 虚拟机在“已启动”时，是按时长收费的，不管是否运行了应用程序；
- 虚拟机在“已关闭”时，仍然收费（Azure的这个设计让用户有些不解，并因此忘记释放资源而继续被动付费）；
- 虚拟机在“已释放”后，停止收费，但是“释放”并非“销毁”，里面安装的应用和数据还是可以打开虚拟机后再重新加载继续使用的，不会丢失；
- 虚拟机在删除后，数据全部丢失。

把上面的策略总结成状态转换，如图 14.8.2 所示。


<img src="img/Slide19.SVG"/>

图 14.8.2 - 虚拟机状态设计


### 14.8.3 错误的状态设计

初学者在做状态设计的时候，会出现的一些常见错误如图 14.8.3 所示。


<img src="img/Slide19.SVG"/>

图 14.8.3 - 错误的状态设计


这同样是虚拟机的状态设计，存在三个问题：

1. 状态域不正确
   
   我们可以对比图 14.8.2，就可以发现问题：本图中“启动中”和“已关闭”状态是正确的虚拟机状态域，都是属于硬件和操作系统级别的状态；但是“空闲”和“繁忙”并不是，它们是属于应用软件系统的状态。

2. 状态/事件缺失
   
   和上一个状态域不正确的问题合并，缺失“已启动”、“关闭中”两个状态，实际上“空闲”应该是“已启动”，“繁忙”应该是“关闭中”。因为关闭不是瞬间完成的，如果可以瞬间完成的话，那么事件应该是“掉电”。

3. 状态跳跃不正确

   我们先假设“繁忙”是正确的状态，从“繁忙”跳到“已关闭”的话，会有很多应用数据丢失，所以必须从“繁忙”先跳到“空闲”，把正在执行的任务优雅地停止，保存好状态数据，然后才能关闭。







## 11.6 交互设计

上一节中得到了控制中心的状态设计，下面我们要设计控制中心、训练子系统、预测子系统、存储服务，还有参与者之间的交互关系，让整个系统能够运转起来。

交互设计是用于描述对象之间的交互关系，可以用两种图来辅助设计，一是协作图，二是顺序图。

### 11.6.1 协作图

协作图描述对象之间的协作关系，进一步弥补了 11.4 节中关于通知/调用的顺序问题。


<img src="img/Slide20.SVG"/>

图 11.6.1 - 协作图


在图 11.6.1 中，以“控制中心”对象（也可以叫做模块、子系统等等）为中心，连接起来周围的几个对象，所有的对象都与控制中心有交互，而对象之间（除了存储）基本没有交互。

为什么存储是个例外呢？因为存储在这里作为一个底层的公共模块，最好是被所有模块直接访问，如果都通过控制中心来访问的话，就太 Heavy 了。除了一种情况：对于存储，你的系统封装了一层业务逻辑，或者存储是一种分布式的，必须通过单点访问。

图 11.6.1 的左侧列出了右侧连接线上的序号所代表的实际交互行为，是按顺序发生的。连线的箭头方向表示交互的发起者到接收者的方向，而不是数据流或信息流的方向。

交互行为有以下几种：

- 人机交互
  
  人操作计算机，可以是键盘、语音、手势等，比如 1，13。

- 本地运行程序
  
  启动一个可执行文件，比如 6。

- 远过程调用
  
  以 TCP/IP 为基础的自定义通信协议，在本例中，使用 ssh 方式登录到其它机器上，然后执行程序。比如 4。

- RESTful API

  通过 RESTful API 调用服务器上的功能。比如 3，11。

- 网页访问
  
  用浏览器与服务器进行交互，执行简单逻辑。比如 9。

- 数据访问
  
  存取数据库、块存储、数据文件等。比如 2，5，7，10，14。

- 邮件通知
  
  通过第三方的电子邮件系统，异步通知对方做下一步动作。比如 8，12。这种方式比较特殊，由于大家对电子邮件方式非常熟悉，所以不做详细说明。在电子邮件内容或附件中，一般包含了下一步动作的指示。

