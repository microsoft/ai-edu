
## 14.9 第七步：接口设计


### 14.9.1 交互与接口

#### 1. 交互行为定义

交互行为有以下几种：

- 人机交互
  
  人操作计算机，可以是键盘、语音、手势等，比如 1,11。可以是启动应用程序或者输入信息。

- 远过程调用
  
  以 TCP/IP 为基础的自定义通信协议，在本例中，使用 ssh 方式登录到其它机器上，然后执行程序，比如 4。

- RESTful API

  通过 RESTful API 调用服务器上的功能，比如 3。

- 网页访问
  
  用浏览器与服务器进行交互，执行简单逻辑。本例中没有。

- 数据访问
  
  存取数据库、块存储、数据文件等，比如 2,5,7,12。

- 收发邮件
  
  通过第三方的电子邮件系统，异步通知对方做下一步动作，比如 9,10。这种方式比较特殊，由于大家对电子邮件方式非常熟悉，所以不做详细说明。在电子邮件内容或附件中，一般包含了下一步动作的指示。

#### 2. 接口技术选择

这里的接口指的是子系统之间的接口，而不是具体的编程语言接口，如 Java、C# 中定义的接口。另外，简单的 API 调用也不是我们要讨论的接口，我们主要讨论跨越进程甚至物理机器之间的接口设计问题。

在 14.7 节的运行设计中，我们确定了两个组件（子系统）之间如何交互，现在要设计具体接口，即：

1. 使用什么技术？
2. 传送什么数据？
3. 返回什么结果？

接口技术的选择：

- Web Service
  
  使用SOAP（Simple Object Access Protocol，简单对象访问协议）提供了在各种平台、框架上运行的不同软件之间可以进行互操作的标准方法。

- Web API/REST API
  
  使用 HTTP 协议的 GET、POST、PUT、DELETE 操作封装 JSON 数据作为参数，驱动服务器完成指定任务。

- RPC（Remote Procedure Call，远过程调用）
  
  有很多中间件可以完成 RPC，调用者在本地使用一个简单的 API，透明地通过服务器传递给被调用者完成指定功能。

- 管道
  
  是一种简单的 IPC（进程间通信）机制，可以是单向的或双向的，传送自定义消息，接收方自行解释执行相应功能。

- Message Queue

  消息队列，FIFO先入先出，是一种进程间通信的方式，接收方繁忙或掉线时，消息不会丢失，直到接收方可以重新主动获得消息。

- Socket

  最底层的套接字通讯，自己封装数据包并在发送和接收端解析，完成指定功能并返回给对方。


在本系统中由于有了控制中心的存在，使得不同子系统之间的网状连接变成了与控制中心的星形连接，大大简化了通信成本。由此可见，当系统中存在4个以上的子系统时，一定要使用星形连接来构建。



【最佳实践】虽然可以有多种 UML 图可以使用，但是协作图是最直观清晰的工具，设计者可以针对每条线和序号来考虑如何实现这种交互，以便进一步制定接口。


下面我们逐个设计每个组件需要的外部接口。

### 14.9.2 协作图

在 14.7 运行设计中，图 14.7.2 和图 14.7.3 已经绘制出了各组件之间的通信过程，但是，时序图关注在时间顺序上，运行设计图关注在进程线程上。因此，这一节需要用一个协作图来理清接口问题。

协作图和时序图一样也是一种交互图，又可以叫做合作图、通信图，它关注对象在参与具体交互时，对象之间如何链接以及传递什么消息。协作图按时间和空间的顺序描述系统元素之间的交互和关系，描述了对象与对象之间的协作/合作关系，侧重说明对象的消息传递，强调发送和接收消息的对象之间的组织结构。协作图的建模结果用于获取对象的职责和接口。

<img src="img/Slide20.SVG"/>

图 11.9.1 协作图

在图 11.9.1 中，以“控制中心”对象（也可以叫做模块、子系统等等）为中心，连接起来周围的几个对象，对象之间发送和接收消息。协作图和时序图可以互相转换而不会丢失信息。但是在协作图中，笔者只绘制了必要的消息链，以便设计必要的接口。

比如：序号 5 的交互消息是“客户端通知控制中心上传数据完毕”，使用了 HTTP POST。如果在时序图中，需要返回一个应答，如 200 OK；但是在本协作图中，这个应答其实对后续的协作没有实际意义，所以就没有画出来。

另外，本协作图把训练子系统纳入流程中，假设数据上传完毕后先进行模型训练，然后使用最新模型进行推理。这是在每 60 个交易日时发生的实际应用场景，在图 14.7.2 的时序图中只描述了平时的推理过程，不包括训练过程。


表 14.9.1 消息序号的具体含义及接口设计

|序号|含义|接口|参数|返回|接口提供者|
|-|-|-|-|-|-|
|1|客户执行上传脚本|upload.bat|本地目录|界面提示|客户端软件|
|2|获得上下文|curl.exe|HTTP GET<br>/api/获得时间戳|sid<br>时间戳|控制中心|
|3|数据上传到存储|AzCopy.exe|本地目录+sid|界面提示|*Azure存储|
|4|发送训练通知|curl.exe|HTTP POST<br>/api/启动训练/sid|200 OK|控制中心|
|5|启动训练子系统|API:start_k8s|%vm_count|succeed|*Azure集群|
|6|读取训练数据|API:read_blob|%sid|训练数据|*Azure存储|
|7|保存训练结果模型|API:save_model|%seqID(序号)|succeed|模型管理模块|
|8|保存训练结果模型|API:save_blob|%seqID|succeed|*Azure存储|
|9|通知训练完毕|HTTP POST|/api/训练结束/sid|200 OK|控制中心|
|10|启动推理子系统|SSH|user@ip -i key ./exec.sh sid|停等|推理虚拟机|
|11|提取可用模型地址|API:get_model|%seqID|模型地址|模型管理模块|
|12|提取可用模型|API:read_blob|%seqID|模型数据|*Azure存储|
|13|读取推理数据|API:read_blob|%sid|推理数据|*Azure存储|
|14|保存推理结果和日志|API:save_blob|%sid|succeed|*Azure存储|
|15|返回控制中心|SSH 结束|N/A|停等返回|*Linux OS|
|16|发送邮件通知|API:send_email|%sid|succeed|*邮件服务器|
|17|客户查收邮件|手工接收|N/A|邮件|*邮件客户端|
|18|启动下载脚本|download.bat|%sid|界面提示|客户端软件|
|19|下载推理结果|AzCopy.exe|本地目录+sid|推理结果|*Azure存储|
|如失败|
|17|工程师收到邮件|手工接收|N/A|邮件|*邮件客户端|
|18|登录系统排查|手工处理|N/A|succeed|*AzureVM|

表 14.9.1 说明了图 11.9.1 中各序号的消息的具体含义，以及对应的接口设计。最后一列“接口提供者”的含义是在本系统中哪个具体的计算节点提供该接口，比如“控制中心”、“推理虚拟机”、“模型管理模块”。其中，不属于本系统的接口提供者是（换句话说，不需要自己写服务器端代码的，都用 *标记）：

- Azure 存储，实际上是一种服务，它可以脱离任何具体的计算节点而直接提供访问服务，就好比一个计算机上挂了很多巨大的硬盘，而客户只关心如何访问位于这些硬盘上的属于自己的数据并为之付费，而不必为那台计算机付费。
- Linux OS，属于本系统的计算节点，但是 ssh 服务是 Linux 操作系统自身提供的。
- 邮件服务器和邮件客户端，第三方的免费软件。

客户端软件提供人机交互接口，属于本系统的计算节点，在 Azure 之外的客户端计算机上运行。

### 14.9.3 接口

<img src="img/Slide21.SVG"/>

图 14.9.1 - 客户端需要的接口

#### 1. 客户端所需外部接口

A1 包括两个方法，A2 只有一个方法，A3 包括两个方法。

- A11：获得时间戳
   
   - 方法：GET /api/get_timestamp/
   - 目标：控制中心
   - 返回：\<timestamp\> 时间戳

   客户端每周都要上传一次数据，带有强烈的时间信号，所以我们设计用时间戳来表示本批次的数据，时间戳的格式是“YYYYmmddHHMMSS”，即“年月日时分秒”。

- A12：发送训练通知

   - 方法：GET /api/start_train/\<timestamp\>
   - 目标：控制中心
   - 返回：200 OK

   这个方法用 POST 也是可以的，只不过用 GET 可以简化编程，也没有歧义。后面很多方法与此相同。
   
   客户端脚本上传完数据后，直接用 curl.exe 可执行文件调用该接口，通知控制中心开始后续的工作。至于后续的工作是什么，由控制中心决定。

- A2：接收邮件
  - 方法：邮件客户端软件
  - 目标：外部邮件系统
  - 返回：邮件内容，内含时间戳信息，指出下载地址。

  甲方会收到控制中心发送的邮件通知，然后使用本地的邮件客户端接收邮件。内容是告知甲方上传数据完毕或可以下载预测结果文件。

- A31：保存 Azure 存储服务，上传股票数据文件
  - 方法：AzCopy.exe 可执行程序
  - 目标：Azure 存储服务
  - 返回：成功或失败

- A32：读取 Azure 存储服务，下载推理结果文件
  - 方法：AzCopy.exe 可执行程序
  - 目标：Azure 存储服务
  - 返回：成功或失败


#### 2. 控制中心所需外部接口

- B1：启动推理子系统
  - 方法：使用系统命令行接口调用 ssh 远程登录并执行指定启动代码
  - 目标：推理子系统
  - 返回：停等，直到预测过程结束后返回控制权

  控制中心需要预测子系统暴露出启动接口。

- B2：启动训练子系统
  - 方法：使用系统命令行接口调用 ssh 远程登录并执行指定启动代码
  - 目标：训练子系统
  - 返回：停等，直到训练过程结束后返回控制权

  控制中心需要训练子系统暴露出启动接口。

- B3：发送邮件通知

  - 方法：本地 API 调用（SMTP 协议 Python 支持包）
  - 目标：外部邮件系统
  - 返回：成功或失败

  控制中心需要发送邮件给外部邮件系统。

#### 3. 训练子系统所需外部接口

- C1：通知控制中心训练结束
  - 方法：HTTP GET /api/train_finished
  - 目标：控制中心
  - 返回：成功或失败

- C2：保存模型
  - 方法：调用 API 保存模型
  - 目标：调用模型模块
  - 返回：成功或失败

- C3：访问 Azure 存储服务读取训练数据
  - 方法：本地 API 调用（安装 Azure 的 Python 支持包）读取或者存储文件
  - 目标：Azure 存储服务
  - 返回：成功或失败

#### 4. 推理子系统所需外部接口

- D1：通知控制中心推理结束
  - 方法：SSH 进程结束
  - 目标：控制中心
  - 返回：成功或失败

- D2：获得最新模型
  - 方法：本地 API 调用（安装 ML-flow 的 Python 支持包）读取最新模型文件
  - 目标：模型管理模块
  - 返回：成功或失败

- D31：访问 Azure 存储服务提取模型
  - 方法：本地 API 调用（安装 Azure 的 Python 支持包）读取文件
  - 目标：Azure 存储服务
  - 返回：成功或失败
  
- D32：访问 Azure 存储服务读取推理数据
  - 方法：本地 API 调用（安装 Azure 的 Python 支持包）读取文件
  - 目标：Azure 存储服务
  - 返回：成功或失败

- D33：访问 Azure 存储服务保存推理结果和运行日志
  - 方法：本地 API 调用（安装 Azure 的 Python 支持包）存储文件
  - 目标：Azure 存储服务
  - 返回：成功或失败


#### 5. 模型管理模块所需外部接口

- E1：访问 Azure 存储服务
  - 方法：本地 API 调用（安装 Azure 的 Python 支持包）存储模型
  - 目标：Azure 存储服务
  - 返回：成功或失败




图 11.6.3 - 客户子系统的


<img src="img/Slide24.SVG"/>

