
## 14.9 第七步：接口设计


### 14.9.1 交互与接口

#### 1. 交互行为定义

交互行为有以下几种：

- 人机交互
  
  人操作计算机，可以是键盘、语音、手势等，比如 1,11。可以是启动应用程序或者输入信息。

- 远过程调用
  
  以 TCP/IP 为基础的自定义通信协议，在本例中，使用 ssh 方式登录到其它机器上，然后执行程序，比如 4。

- RESTful API

  通过 RESTful API 调用服务器上的功能，比如 3。

- 网页访问
  
  用浏览器与服务器进行交互，执行简单逻辑。本例中没有。

- 数据访问
  
  存取数据库、块存储、数据文件等，比如 2,5,7,12。

- 收发邮件
  
  通过第三方的电子邮件系统，异步通知对方做下一步动作，比如 9,10。这种方式比较特殊，由于大家对电子邮件方式非常熟悉，所以不做详细说明。在电子邮件内容或附件中，一般包含了下一步动作的指示。

#### 2. 接口技术选择

这里的接口指的是子系统之间的接口，而不是具体的编程语言接口，如 Java、C# 中定义的接口。另外，简单的 API 调用也不是我们要讨论的接口，我们主要讨论跨越进程甚至物理机器之间的接口设计问题。

在 14.7 节的运行设计中，我们确定了两个组件（子系统）之间如何交互，现在要设计具体接口，即：

1. 使用什么技术？
2. 传送什么数据？
3. 返回什么结果？

接口技术的选择：

- Web Service
  
  使用SOAP（Simple Object Access Protocol，简单对象访问协议）提供了在各种平台、框架上运行的不同软件之间可以进行互操作的标准方法。

- Web API/REST API
  
  使用 HTTP 协议的 GET、POST、PUT、DELETE 操作封装 JSON 数据作为参数，驱动服务器完成指定任务。

- RPC（Remote Procedure Call，远过程调用）
  
  有很多中间件可以完成 RPC，调用者在本地使用一个简单的 API，透明地通过服务器传递给被调用者完成指定功能。

- 管道
  
  是一种简单的 IPC（进程间通信）机制，可以是单向的或双向的，传送自定义消息，接收方自行解释执行相应功能。

- Message Queue

  消息队列，FIFO先入先出，是一种进程间通信的方式，接收方繁忙或掉线时，消息不会丢失，直到接收方可以重新主动获得消息。

- Socket

  最底层的套接字通讯，自己封装数据包并在发送和接收端解析，完成指定功能并返回给对方。


在本系统中由于有了控制中心的存在，使得不同子系统之间的网状连接变成了与控制中心的星形连接，大大简化了通信成本。由此可见，当系统中存在4个以上的子系统时，一定要使用星形连接来构建。



【最佳实践】虽然可以有多种 UML 图可以使用，但是协作图是最直观清晰的工具，设计者可以针对每条线和序号来考虑如何实现这种交互，以便进一步制定接口。


下面我们逐个设计每个组件需要的外部接口。

### 14.9.2 协作图

在 14.7 运行设计中，图 14.7.2 和图 14.7.3 已经绘制出了各组件之间的通信过程，但是，时序图关注在时间顺序上，运行设计图关注在进程线程上。因此，这一节需要用一个协作图来理清接口问题。

协作图是一种交互图，它关注对象在参与具体交互时，对象之间如何链接以及传递什么消息。协作图按时间和空间的顺序描述系统元素之间的交互和关系，侧重于描述消息的组成关系。

<img src="img/Slide20.SVG"/>

图 11.9.1 协作图

在图 11.9.1 中，以“控制中心”对象（也可以叫做模块、子系统等等）为中心，连接起来周围的几个对象：


|序号|含义|交互接口|参数|接口提供者|
|-|-|-|-|-|
|1|客户执行上传脚本|upload.bat|N/A||
|2|请求上下文|curl.exe|HTTP GET /api/get_timestamp |控制中心|
|3|获得上下文|HTTP Response| sid（时间戳）|控制中心|
|4|数据上传到存储|AzCopy.exe|本地目录+sid|Azure 存储服务|
|5|通知上传完毕|curl.exe|HTTP GET /api/start_train/sid |控制中心|
|6|启动训练子系统|API:start_k8s|%vm_count|Azure 存储服务|
|7|读取训练数据|API:read_blob|%sid|Azure 存储服务|
|8|保存训练结果模型|API:save_blob|%seqID（内部序号）|Azure 存储服务|
|9|通知训练完毕|HTTP GET|/api/stop_train/sid|控制中心|
|10|启动推理子系统|SSH|user@ip -i key.pem ./exec.sh sid|推理虚拟机|
|11|提取模型|API:get_model|%seqID|模型管理模块|
|12|读取推理数据|API:read_blob|%sid|Azure 存储服务|
|13|保存推理结果和日志|API:save_blob|%sid|Azure 存储服务|
|14|返回控制中心|SSH 结束|N/A|Linux OS|
|15|发送邮件通知|API:send_email|%sid|邮件服务器|
|16|客户收到邮件|手工接收|N/A|邮件客户端|
|17|启动下载脚本|download.bat|%sid||
|18|下载推理结果|AzCopy.exe|本地目录+sid|Azure 存储服务|
|如失败|
|16|工程师收到邮件|手工接收|N/A|邮件客户端|
|17|登录系统排查|手工处理|N/A||


### 14.9.2 客户端需要的外部接口


<img src="img/Slide21.SVG"/>

图 14.9.1 - 客户端需要的接口


#### 接口 A1

包括两个方法：

- 获得时间戳
   
   - 方法：GET /api/get_timestamp/
   - 目标：控制中心
   - 返回：\<timestamp\> 时间戳

   客户端每周都要上传一次数据，带有强烈的时间信号，所以我们设计用时间戳来表示本批次的数据，时间戳的格式是“YYYYmmddHHMMSS”，即“年月日时分秒”。

- 通知上传数据完毕

   - 方法：GET /api/start/\<timestamp\>
   - 目标：控制中心
   - 返回：200 OK

   这个方法用 POST 也是可以的，只不过用 GET 可以简化编程，也没有歧义。后面很多方法与此相同。
   
   客户端脚本上传完数据后，直接用 CURL.exe 可执行文件调用该接口，通知控制中心开始后续的工作。至于后续的工作是什么，由控制中心决定。

#### 接口 A2

- 接收邮件
  - 方法：邮件客户端软件
  - 目标：外部邮件系统
  - 返回：邮件内容，内含网页链接

  甲方会收到控制中心发送的邮件通知，然后使用本地的邮件客户端接收邮件。内容是告知甲方上传数据完毕或可以下载预测结果文件。

#### 接口 A3

- 存取 Azure 存储服务
  - 方法：AzCopy.exe 可执行程序
  - 目标：Azure 存储服务
  - 返回：成功或失败

  客户端上传、下载数据文件时使用。

#### 接口 B1

包括四个方法：

- 检查训练结果
   - 方法：GET /api/review_training_result/\<timestamp\>
   - 目标：控制中心
   - 返回：HTML 格式网页
  
  这个接口实际上返回一个网页，研究员需要用此网页来检查训练结果的正确性，避免需要登录到 Azure 虚拟机上检查的麻烦。

- 确认训练结果
  - 方法：GET /api/confirm_training_result/\<timestamp\>
  - 目标：控制中心

  在上面的接口方法返回的网页上，有一个按钮，研究员可以点击此按钮调用 REST API 触发本接口，控制中心将接到通知，进行下一步操作（进入下一个状态）。

- 检查预测结果
   - 方法：GET /api/review_inference_result/\<timestamp\>
   - 目标：控制中心
   - 返回：HTML 格式网页
  
  这个接口实际上返回一个网页，研究员需要用此网页来检查训练结果的正确性，避免需要登录到 Azure 虚拟机上检查的麻烦。

- 确认预测结果
  - 方法：GET /api/confirm_inference_result/\<timestamp\>
  - 目标：控制中心
  - 返回：

  在上面的接口方法返回的网页上，有一个按钮，工程师可以点击此按钮调用 REST API 触发本接口，控制中心将接到通知，进行下一步操作（进入下一个状态）。
  
#### 接口 B2

- 接收邮件
  - 方法：邮件客户端软件
  - 目标：外部邮件系统
  - 返回：邮件内容，内含网页链接

  乙方会收到控制中心发送的邮件通知，然后使用本地的邮件客户端接收邮件。内容是告知研究员训练完毕，需要检查训练结果并确认，或者是告知工程师预测完毕，需要检查预测结果并确认。


### 14.9.3 控制中心需要的外部接口


<img src="img/Slide22.SVG"/>

图 14.9.2 - 控制中心需要的外部接口


#### 接口 C1

- 启动预测子系统
  - 方法：使用系统命令行接口调用 ssh 远程登录并执行指定启动代码
  - 目标：预测子系统
  - 返回：停等，直到预测过程结束后返回控制权

  控制中心需要预测子系统暴露出启动接口。

#### 接口 C2

- 启动训练子系统
  - 方法：使用系统命令行接口调用 ssh 远程登录并执行指定启动代码
  - 目标：训练子系统
  - 返回：停等，直到训练过程结束后返回控制权

  控制中心需要训练子系统暴露出启动接口。

#### 接口 C3

- 访问 Azure 存储服务
  - 方法：得到预测或者训练的文本输出
  - 目标：Azure 存储服务
  - 返回：得到文本文件内容

  控制中心需要访问 Azure 存储服务读取指定文本文件内容。

#### 接口 C4

- 发送邮件通知

  - 方法：本地 API 调用（SMTP 协议 Python 支持包）
  - 目标：外部邮件系统
  - 返回：成功或失败

  控制中心需要发送邮件给外部邮件系统。

### 14.9.4 内部子系统需要的外部接口


<img src="img/Slide22.SVG"/>

图 11.6.3 - 训练/预测/管理需要的外部接口


#### 接口 D1

- 访问 Azure 存储服务
  - 方法：本地 API 调用（安装 Azure 的 Python 支持包）读取或者存储文件
  - 目标：Azure 存储服务
  - 返回：成功或失败

  预测子系统需要读取 Azure 存储服务上的数据文件，把预测结果保存到存储。

#### 接口 D2

- 获得最新模型
  - 方法：本地 API 调用（安装 ML-flow 的 Python 支持包）读取最新模型文件
  - 目标：模型管理子系统
  - 返回：成功或失败

  预测子系统从模型管理子系统获得最新发布的模型文件。

#### 接口 E1

- 写入模型
  - 方法：本地 API 调用（安装 ML-flow 的 Python 支持包）写入模型文件
  - 目标：模型管理子系统
  - 返回：成功或失败

  训练子系统把训练好的模型写入模型管理子系统。

#### 接口 E2

- 访问 Azure 存储服务
  - 方法：本地 API 调用（安装 Azure 的 Python 支持包）读取或者存储文件
  - 目标：Azure 存储服务
  - 返回：成功或失败

  训练子系统把训练结果写入 Azure 存储服务上的文本文件。

#### 接口 F1

- 访问 Azure 存储服务
  - 方法：本地 API 调用（安装 Azure 的 Python 支持包）读取或者存储文件
  - 目标：Azure 存储服务
  - 返回：成功或失败

  模型管理子系统（ML-flow）需要使用 Azure Blob 作为模型试验存储。



<img src="img/Slide23.SVG"/>

图 11.6.3 - 客户子系统的


<img src="img/Slide24.SVG"/>

