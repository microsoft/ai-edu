

## 3.1 租车还车问题

### 3.1.1 提出问题

在北京有一个叫做“四通八达”的租车连锁公司，在海淀区、朝阳区、通州区、丰台区开设了 4 个门店，编号分别为 A,B,C,D。客户可以从任意一个店租车，用完后可以归还到任意一个店。为了简化问题，我们假设客户都是早晨租车开走，晚上归还。

<center>
<img src="./img/Car-map.png">

图 3.1.1 租车还车问题
</center>

为了招徕顾客，公司特地买了一辆高档宝驴车，以普通价格出租。公司经理想知道如果有一天这辆车从B号店出租了，2 天后的早晨会最有可能在哪个店出现？5 天后又会如何？

### 3.1.2 统计数据

公司统计了去年全年 100 辆车的 100 天的租车、还车记录，抽样以后发现这 100 辆车在四个店的流动情况是这样的：

```
1）   B A A B A B A D ......
2）   C B A B A B A D ......
      ......
100） A B A D C C C B ......
```

*注：上述数据是用 RentCar_0_Data.py 生成的，并保存在 CarData.txt 文本文件中便于阅读。如果再次运行本代码，因为随机序列不同，将会生成不同的数据序列。*

数据序列的含义是：
- 每辆车是一行记录，一共 100 行记录
- 每行记录含有 100 个元素

以最后一辆车为例：

- 第一天从A店被租走，晚上还到B店；
- 第二天从B店被租走，晚上还到A店；
- 第三天从A店被租走，晚上还到D店；
- 第四天从D店被租走，晚上还到C店；
- ......

有了这个状态序列后，可以很容易地通过遍历数据序列统计次数：

1. 指定要统计的对象，比如是从 B 租出，在 A 还回，则 rent_from = B，return_from = A；
2. 设置两个计数器，一个 $nA = 0$，一个 $nB = 0$；
3. 在上述序列数据中先找到所有的 B，出现一次就记录 $nB = nB+1$；
2. 再找到 B 后面出现间隔 2 天出现的 A，如果有，则计数器 $nA=nA+1$；
   比如：
   - 如果是 [...B, C, A...] 的顺序，则 $nB$ 计数，$nA$ 也计数一次。问号表示任意字母。
   - 如果是 [...B, B, A, A...] 的顺序，则要分别计数两次。

【代码位置：RentCar_1_FromB.py】

关键函数代码如下：

```Python
# 统计rent_from出现的次数，以及经过t天转移到return_to的次数
def counter_from_t_to(X, rent_from, return_to, t):
    n_from = 0
    n_to = 0
    for x in range(len(X)-t):
        if rent_from == X[x]:
            n_from += 1
            if return_to == X[x+t]: # {t} 天后还到 {return_to} 店
                n_to += 1
    return n_from, n_to
```

运行后得到以下结果：

```
天数 = 2
B->A : 2979,238
B->B : 2979,1258
B->C : 2979,66
B->D : 2979,1417
天数 = 5
B->A : 2888,932
B->B : 2888,747
B->C : 2888,529
B->D : 2888,680
```
在这10000个数据中，该车从 B 店租出：
- 经过 2 天，在四个店出现的数字是：[238, 1258, 66, 1417]，就是说最有可能在 D 店出现，其次是 B 店。
- 经过 5 天，在四个店出现的数字是：[932, 747, 529, 680]，就是说最有可能在 A 店出现，但是比起 2 天的数据，5 天的数据没有很强的倾向性了。

这似乎已经回答了经理的问题，但是这其中有什么隐藏的规律呢？

其实这是一个标准的**转移概率**的问题。
