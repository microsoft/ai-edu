
## 7.2 动态规划与贝尔曼方程

### 7.2.1 动态规划与贝尔曼方程

想解决开发流程这个问题，如果像安全驾驶问题中一样用蒙特卡洛采样方法，仍然可以得到估算出来的状态价值函数 V。但是在本章，我们要学习一种更科学的方法，被称作贝尔曼方程。

贝尔曼方程（Bellman Equation）也被称作动态规划方程（Dynamic Programming Equation），由理查·贝尔曼（Richard Bellman）发现。贝尔曼方程最早应用在工程领域的控制理论和其他应用数学领域，而后成为经济学上的重要工具。

动态规划是把一个规划问题转化为抽象状态之间的转移，因此，模型的细节，比如状态转移概率。做正确决策所需要当前情况的信息被称作是状态（State）。例如，为了决定要不要给一个软件系统增加一个新功能，管理者必须知道目前的状态，比如人员、时间、Bug 数量、代码规模等等，这些都是状态变量，可以影响软件质量，并用于决策软件发布时间。

动态规划方法主要用来解决优化问题，投资问题、库存问题、生产计划、资源分配、设备更新、最优搜索、马尔可夫决策过程，以及最优控制和自适应控制等问题，均可用动态规划方法来处理。所以在介绍用于计算 V 函数的算法之前，我们先一起简单地复习一下动态规划。

### 7.2.2 动态规划

**Those who cannot remember the past are condemned to repeat it.**

**那些不记得过去的人注定要重蹈覆辙。** 

这是动态规划的经典名句。下面我们先回忆一下动态规划的基本思想。

动态规划（Dynamic Programming，简称DP）动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。

动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。 通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量： 一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。 这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。虽然抽象后进行求解的思路并不复杂，但具体的形式千差万别，找出问题的子结构以及通过子结构重新构造最优解的过程很难统一，为了解决动态规划问题，只能靠多练习、多思考了。

#### 姐弟俩的故事一

妈妈问：“$1+2+3+4=?$”
弟弟（一年级小学生，花了30秒在纸上做加法演算然后）答：“等于10。”
爸爸问：“很好！那么 $7+4+3+2+1=?$”
姐姐（五年级小学生花了2秒思考然后立刻）答：“等于17。”
弟弟把刚拿起来的铅笔放下，无限崇拜地看着姐姐：“你是怎么这么快算出来的？”
姐姐说：“在你的答案上直接加 7 就行了。”
爸爸说：“不错，已经知道**利用历史经验**了！”

#### 姐弟俩的故事二

有一个 6 级的台阶，姐姐和弟弟每天放学回家都要经过。弟弟有时候一级一级地上台阶，有时候跳两级，有时候一级两级随意上跳，但是方法每天都不一样，姐姐在旁边帮他记录，保证他不重复。问：弟弟一共需要多少天可以遍历所有跳法？这次需要输出所有数列（1级时输出1，2级时输出2，3级时输出3，4级时输出5......）。

其实这是一个斐波那契数列的变形题目，可以抽象为：

$$
\begin{aligned}
f(1)&=1
\\
f(2)&=2
\\
f(n)&=f(n-1)+f(n-2)
\end{aligned}
$$

其解题思路在于把问题逐级分解：

- 想跳到第 6 级台阶，先要跳到第 5 级或第 4 级台阶；
  又分成两种情况：
  - 想跳到第 5 级台阶，先要跳到第 4 级或第 3 级台阶；
    双分成两种情况：
    - 想跳到第 4 级台阶，先要跳到第 3 级或第 2 级台阶；
      叒分成两种情况：
      - 想跳到第3级台阶，先要跳到第 2 级或第 1 级台阶；
      - 想跳到第2级台阶，先要跳到第 1 级台阶。
            ......
  - 想跳到第 4 级台阶，先要跳到第 3 级或第 2 级台阶；
        ......

所以有：

$$
\begin{aligned}
f(6)&=f(5)+f(4) & {\footnotesize (到第 6 级台阶的方法有 5 \to 6 和 4 \to 6 两种组合)}
\\
f(5)&=f(4)+f(3)
\\
f(3)&=f(2)+f(1)
\\
f(2)&=2 & {\footnotesize (两级台阶有2种跳法)}
\\
f(1)&=1 & {\footnotesize (一级台阶只有1种跳法)}
\end{aligned}
$$

下面用三种方法来解决这个问题：
- 递归法
- 迭代法
- 备忘录法

【代码位置：DP_1.py】

```python
# 递归法
def f1(n):
    if n==1 or n==2:
        return n
    else:
        fn = f1(n-1) + f1(n-2)  # 递归调用函数本身两次 f(n)=f(n-1)+f(n-2)
        return fn
```

递归法是自顶向下递归调用自己，不能存储任何中间过程，而且耗用内存较多，在问题复杂时容易造成堆栈溢出。

```python
# 迭代法
def f2(n):
    fn_2 , fn_1 = 1, 2      # f(n-2)=1, f(n-1)=2
    for i in range(n-2):
        fn = fn_2 + fn_1    # 计算 f(n) = f(n-2)+f(n-1)
        fn_2 = fn_1         # 迭代更换上一次的数值便于下次计算
        fn_1 = fn
    return fn
```

迭代法是自底向上一步步计算，用变量存储上一步的计算结果，用于下一步。

```python
# 备忘录法
def f3(n):
    results = {1:1, 2:2}    # 建立字典，初始时，当n=1和n=2时的结果是1和2
    for i in range(3, n+1):
        fi = results[i-1] + results[i-2]    # 从字典中直接取出结果计算f(n)=f(n-2)+f(n-1)
        results[i] = fi     # 在字典中添加n=i时的结果,i=3,4,5...
    return results
```

备忘录法使用公共存储来存储所有的历史计算结果，在需要的时候直接拿出来使用，可以记录所有历史记录。

上述三个算法的输入参数都是 n，表示步数，我们先令 n=6 来看看结果。

输出结果：
```
========================================
递归法结果 = 13
递归法耗时 = 0.0
========================================
迭代法结果 =  13
迭代法耗时 = 0.0009682178497314453
========================================
备忘录法结果 = {1: 1, 2: 2, 3: 3, 4: 5, 5: 8, 6: 13}
备忘录法耗时 = 0.001001119613647461
```
所以 6 级台阶一共有 13 种跳法。其中，备忘录法可以记录所有的计算结果，当然需要耗费 $O(n)$ 空间。

如果台阶数增加到 n=40，当计算 $f(40)$ 时，递归法需要花费成指数级增加的时间，在笔者的电脑上约17秒，复杂度为 $O(2^n)$。而迭代法和备忘录法仍然是瞬时完成，复杂度 $O(n)$。

```
========================================
递归法结果 = 165580141
递归法耗时 = 16.985862016677856
========================================
迭代法结果 =  165580141
迭代法耗时 = 0.0010018348693847656
========================================
备忘录法结果 = {1: 1, 2: 2, 3: 3, 4: 5, ......, 38: 63245986, 39: 102334155, 40: 165580141}
备忘录法耗时 = 0.0010018348693847656
```

**递归是朴素的思想，迭代是有效的方法**，两者都要掌握。

### 7.2.3 小结

动态规划问题满足三大重要性质：

- 最优子结构性质
  
  如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。

- 子问题重叠性质
  
  在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中（称作 DP 表格），当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率。

- 无后效性

  将各阶段按照一定的次序排列好之后，对于某个给定的阶段状态，它以前各阶段的状态无法直接影响它未来的决策，而只能通过当前的这个状态。换句话说，每个状态都是过去历史的一个完整总结。这就是无后向性，又称为无后效性。

动态规划最核心的思想，就在于拆分子问题，记住过往，减少重复计算。所以，**动态规划**，简单地说就是**记住求过解来节省后续的计算时间**。

在动态规划问题的解题思路中，重点是**定义 DP 表格的含义 + 状态转移方程**，已经有很多相关文献记载，请读者自行学习。

