
## 7.6 用迭代法解贝尔曼方程

### 7.6.1 迭代法原理

线性方程组和矩阵法都可以解出贝尔曼方程，但是它们各有缺点：

- 用手工列方程组的办法肯定可以得到解，但是当状态数量到几十个时，虽然都是一次线性方程组，手工计算量很大，非常容易出错。

- 矩阵法虽然可以得到数学解析解，但是，计算逆矩阵时非常耗时，时间复杂度为 $O(n^3)$，$n$ 是状态的数量。当状态数量增加到千级、万级时，时间开销将变得不可接受。

式（7.5.3）的形式 $x=f(x)$，让我们想起了迭代法，比如式（7.6.1）所示的方程：

$$
x = 10 + \log_{10}(\frac{x}{2}) \tag{7.6.1}
$$


用迭代法是这样：首先假定等式左侧的 $x$ 为 $x_{[k+1]}$，而右侧的为 $x_{[k]}$，如式（7.6.2）：

$$
x_{[k+1]} = 10 + \log_{10}(\frac{x_{[k]}}{2}) \tag{7.6.2}
$$

后续步骤：

- 任意给定 $x_k$ 的初始值（在本问题中需要 $x>0$，否则 $\log_{10}(\frac{[x_k]}{2})$ 无法计算），计算出 $x_{[k+1]}$；
- 再把 $x_{[k+1]}$ 代入等式右侧，再计算下一轮的$x_{[k+1]}$；
- 如此重复，然后检查 $|x_{[k+1]}-x_{[k]}|$ 是否小于一个给定的误差，即可判定收敛。

写成代码也很简单：

【代码位置：Simple_Iteration.py】

```Python
import math

def f(x):
    y = 10 + math.log10(x/2)
    return y

if __name__=="__main__":
    x = 100
    delta = 100
    count = 0
    while delta > 1e-5:     # 判断是否收敛
        count += 1          # 计数器
        y = f(x)            # 迭代计算
        delta = abs(x - y)  # 检查误差
        print(str.format("{0}: x={1}，相对误差={2}", count, y, delta))
        x = y               # 为下一次迭代做准备
```
在给定 x 初值为 100 的情况下，指定误差 delta 小于 1e-5 即可结束迭代，试验结果如下：

```
1: x=11.698970004336019，相对误差=88.30102999566398
2: x=10.767117631798069，相对误差=0.93185237253795
3: x=10.73106946212392，相对误差=0.03604816967414948
4: x=10.72961301039834，相对误差=0.0014564517255788445
5: x=10.72955406269718，相对误差=5.894770116121606e-05
6: x=10.729551676708828，相对误差=2.3859883508947632e-06
```

共迭代了 6 次，误差达到 2.38e-6，结果为 10.73。读者可自行带入式（7.6.1）中验证。

### 7.6.2 线性迭代法

#### 手工演算

根据上面的思路，我们尝试一下最原始的手工迭代，以帮助读者理解迭代过程。

根据式（7.3.13）

$$
v(s) = R(s)+ \gamma \sum_{s'} p_{ss'}v(s')=R(s)+ \gamma P_{ss'}V(s')
\tag{由式7.3.13}
$$

可以定义 $v_{[k+1]},v_{[k]}$ 的迭代关系如下：

$$
v_{[k+1]}(s) = R(s)+ \gamma \sum_{s'} p_{ss'}v_{[k]}(s')
\\
V_{[k+1]}(s) = R(s)+ \gamma P_{ss'}V_{[k]}(s')
\tag{7.6.3}
$$

后续步骤：

- 可以设置 $V_{[0]}$ 的初始值为全 0，下标 $[0]$ 表示迭代次数（下同），如式（7.6.4）左侧数组；
- 然后根据式（7.6.3）进行第一次迭代，得到各个状态的奖励值 $V_{[1]}$，如式（7.6.4）右侧数组。因为除了 $R(s)$ 以外，$v(s')$ 的值全为 0，所以第一次迭代的结果就等于状态奖励值：

$$
V_{[0]}=
\begin{cases}
v_0=0
\\
v_1=0
\\
v_2=0
\\
v_3=0
\\
v_4=0
\\
v_5=0
\\
v_6=0
\end{cases}
, \qquad V_{[1]}=
\begin{cases}
v_0=-3
\\
v_1=0
\\
v_2=1
\\
v_3=3
\\
v_4=2
\\
v_5=-1
\\
v_6=0
\end{cases}
\tag{7.6.4}
$$

第二次迭代，根据式（7.6.3）可以写出方程组，并把 $V_{[1]}$ 的结果代入：

$$
V_{[2]}=
\begin{cases}
v_0=-3+0.2v_0+0.8v_1=(-3)+0.2\cdot(-3)+0.8\cdot0=-3.6
\\
v_1=0+0.6v_0+0.4v_2 =0+0.6\cdot(-3)+0.4\cdot1=-1.4
\\
v_2=1+0.1v_1+0.9v_3=1+0.1\cdot0+0.9\cdot3=3.7
\\
v_3=3+0.1v_1+0.2v_4+0.7v_5=3+0.1\cdot0+0.2\cdot2+0.7\cdot(-1)=2.7
\\
v_4=2+0.2v_1+0.5v_2+0.3v_3=2+0.2\cdot0+0.5\cdot1+0.3\cdot3=3.4
\\
v_5=-1+v_6=-1+0=-1
\\
v_6=0
\end{cases}
$$

把 $V_{[2]}$ 的结果代入做第三次迭代：

$$
V_{[3]}=
\begin{cases}
v_0=-3+0.2v_0+0.8v_1=(-3)+0.2\cdot(-3.6)+0.8\cdot(-1.4)=-4.84
\\
v_1=0+0.6v_0+0.4v_2 =0+0.6\cdot(-3.6)+0.4\cdot3.7=-0.68
\\
v_2=1+0.1v_1+0.9v_3=1+0.1\cdot(-1.4)+0.9\cdot2.7=3.29
\\
v_3=3+0.1v_1+0.2v_4+0.7v_5=3+0.1\cdot(-1.4)+0.2\cdot3.4+0.7\cdot(-1)=2.84
\\
v_4=2+0.2v_1+0.5v_2+0.3v_3=2+0.2\cdot(-1.4)+0.5\cdot3.7+0.3\cdot2.7=4.38
\\
v_5=-1+v_6=-1+0=-1
\\
v_6=0
\end{cases}
$$

依此类推，读者可以比较 $V_{[0]},V_{[1]},V_{[2]},V_{[3]}$ 的数值，是不是一步步地向着上一小节中用矩阵法得到的结果迈进。

#### 代码实现

做为一名伟大的程序员，我们当然要用代码来解决上述的繁复手工计算过程：

【代码位置：LifeCycle_1_Linear_Equations_Iteration.py】

```Python
# 线性方程组原始迭代法
def linear_equations_iteration(dataModel, gamma):
    print("---原始迭代法---")
    V_new = np.zeros(dataModel.N)   # 初始化为全 0
    count = 0
    while (count < 1000):   # 1000 是随意指定的一个比较大的数，避免不收敛而导致while无限
        V_old = V_new.copy()   # 准备一个备份，用于比较，检查是否收敛
        count += 1  # 计数器+1
        # 列方程组, 更新 V_next 的值
        V_new[0] = dataModel.R[0] + gamma * (0.2 * V_old[0] + 0.8 * V_old[1])
        V_new[1] = dataModel.R[1] + gamma * (0.6 * V_old[0] + 0.4 * V_old[2])
        V_new[2] = dataModel.R[2] + gamma * (0.1 * V_old[1] + 0.9 * V_old[3])
        V_new[3] = dataModel.R[3] + gamma * (0.1 * V_old[1] + 0.2 * V_old[4] + 0.7 * V_old[5])
        V_new[4] = dataModel.R[4] + gamma * (0.2 * V_old[1] + 0.5 * V_old[2] + 0.3 * V_old[3])
        V_new[5] = dataModel.R[5] + gamma * V_old[6]
        V_new[6] = dataModel.R[6]
        if np.allclose(V_new, V_old):  # 检查是否收敛
            break
    print("迭代次数 :", count)
    return V_new
```

上述代码中，V_new 表示 $V_{[k+1]}$，V_old 表示 $V_{[k]}$。

输出结果如下：
```
---原始迭代法---
迭代次数 : 65
状态价值函数计算结果(数组) : [-5.99 -2.24  3.38  2.9   4.11 -1.    0.  ]
Bug:        -5.99
Coding:     -2.24
Test:       3.38
Review:     2.9
Refactor:   4.11
Merge:      -1.0
End:        0.0
```
从结果上看，与矩阵法的结果相同。
