

## 租车问题

### 1 提出问题

在北京有一个叫做“四通八达”的租车连锁公司，在海淀区、朝阳区、通州区、丰台区开设了 4 个门店，编号分别为 A,B,C,D。客户可以从任意一个店租车，用完后可以归还到任意一个店。为了简化问题，我们假设客户都是早晨租车开走，晚上归还。

为了招徕顾客，公司特地买了一辆高档宝驴车，以普通价格出租。公司经理想知道如果有一天这辆车从B号店出租了，2 天后的早晨会最有可能在哪个店出现？5 天后又会如何？

公司统计了去年全年 100 辆车的 100 天的租车、还车记录，抽样以后发现这 100 辆车在四个店的流动情况是这样的：

```
1）   B A A B A B A D ......
2）   C B A B A B A D ......
      ......
100） A B A D C C C B ......
```

*注：上述数据是用 RentCar_0_Data.py 生成的，并保存在 CarData.txt 文本文件中便于阅读。如果再次运行本代码，因为随机序列不同，将会生成不同的数据序列。*

数据序列的含义是：
- 每辆车是一行记录，一共 100 行记录
- 每行记录含有 100 个元素

以最后一辆车为例：

- 第一天从A店被租走，晚上还到B店；
- 第二天从B店被租走，晚上还到A店；
- 第三天从A店被租走，晚上还到D店；
- 第四天从D店被租走，晚上还到C店；
- ......

有了这个状态序列后，可以很容易地通过遍历数据序列统计次数：

1. 指定要统计的对象，比如是从 B 租出，在 A 还回，则 rent_from = B，return_from = A；
2. 设置两个计数器，一个 $nA = 0$，一个 $nB = 0$；
3. 在上述序列数据中先找到所有的 B，出现一次就记录 $nB = nB+1$；
2. 再找到 B 后面出现间隔 2 天出现的 A，如果有，则计数器 $nA=nA+1$；
   比如：
   - 如果是 [...B, C, A...] 的顺序，则 $nB$ 计数，$nA$ 也计数一次。问号表示任意字母。
   - 如果是 [...B, B, A, A...] 的顺序，则要分别计数两次。

【代码位置：RentCar_1_FromB.py】

关键函数代码如下：

```Python
# 统计rent_from出现的次数，以及经过t天转移到return_to的次数
def counter_from_t_to(X, rent_from, return_to, t):
    n_from = 0
    n_to = 0
    for x in range(len(X)-t):
        if rent_from == X[x]:
            n_from += 1
            if return_to == X[x+t]: # {t} 天后还到 {return_to} 店
                n_to += 1
    return n_from, n_to
```

运行后得到以下结果：

```
天数 = 2
B->A : 2979,238
B->B : 2979,1258
B->C : 2979,66
B->D : 2979,1417
天数 = 5
B->A : 2888,932
B->B : 2888,747
B->C : 2888,529
B->D : 2888,680
```
在这10000个数据中，该车从 B 店租出：
- 经过 2 天，在四个店出现的数字是：[238, 1258, 66, 1417]，就是说最有可能在 D 店出现，其次是 B 店。
- 经过 5 天，在四个店出现的数字是：[932, 747, 529, 680]，就是说最有可能在 A 店出现，但是比起 2 天的数据，5 天的数据没有很强的倾向性了。

这似乎已经回答了经理的问题，但是这其中有什么隐藏的规律呢？

其实这是一个标准的**转移概率**的问题。

### 2 转移概率

【代码位置：RentCar_2_OneByOne.py】

转移概率是马尔可夫链中的重要概念，我们后面再讲马尔科夫链，本节先把转移概率的问题搞清楚。

在本问题中，有 4 个门店，所以对于某辆车来说，它第二天早晨出现在哪个门店就有 4 种可能，我们称之为 4 个状态：$[A, B, C, D]$。

如何根据历史数据计算出转移概率呢？其实就是条件概率：
$$
P(X|Y)=\frac{P(X,Y)}{P(Y)} \tag{1}
$$

具体到本问题中，公式如下：

$$
P_{i,j}=\mathbb P \{X_{t+1}=a_j|X_t = a_i\}=\frac{\Pr\{X_{t+1}=a_j,X_t=a_i\}}{\Pr\{X_t=a_i\}}=\frac{a_j在a_i后出现的次数}{a_i出现的总次数}  \tag{2}
$$

公式 2 中各元素的含义是：

- $P_{i,j}$：第 $i$ 个状态转移到第 $j$ 个状态的概率。
- $X_t, X_{t+1}$：t 时刻和 t+1 时刻的状态。
- $a_i, a_j$：第 $i$ 个状态和第 $j$ 个状态，$\in [A,B,C,D]$。

当在某一时刻 $t$，处于 $a_i$ 状态时，下一个时刻 $t+1$ 转移到 $a_j$ 状态的概率。

比较公式 2 和 1，形式上是完全相同的，只是里面的变量更具体化一些。

用上面的具体数据举例说明，如果想统计第一天从 A 店租车，并且第二天在 B 店还车的概率，应该这样做：

1. 设置两个计数器，一个 $nA = 0$，一个 $nB = 0$；
1. 在上述序列数据中先找到所有的 A，出现一次就记录 $nA = nA+1$，假设一共出现 1000 次；
2. 再找到紧接着 A 后面出现的 B，如果有，则计数器 $nB=nB+1$，假设一共 110 次；
    - 如果是 [A, B, C] 的顺序，则 $nA$ 计数，$nB$ 也计数。
    - 如果是 [A, C, B] 的顺序，中间有个'C'，则 $nA$ 计数，$nB$ 不计数。
3. 所有数据都统计完后计算：$P_{A,B} = \frac{nB}{nA}=\frac{110}{1000}=0.11$

统计部分的代码与 RentCar_1_FromB.py 完全相同，只是做了一次遍历调用（双重循环），并指定 t=1：

```Python
if __name__ == "__main__":
    # 读取文件
    data_array = carData.read_data()
    for rent_from in car_1.RentalStore:
        print(str.format("从 {0} 店租出：", rent_from.name))
        for return_to in car_1.RentalStore:
            num_from, num_to = car_1.Statistic(data_array, rent_from, return_to, t=1)
            print(str.format("还到 {0} 店：租出次数={1}, \t归还次数={2}, \t比例={3}", 
                return_to.name, num_from, num_to, num_to/num_from))
```
运行上述代码 RentCar_2_OneByOne.py，统计出 A 店一共出现 2677 次，B 紧接在 A 后出现 813 次，所以 $P_{A,B}=\frac{813}{2677}\approx 0.3$。输出如下：
```
[Out]
从 A 店租出：
还到 A 店：租出次数=2677,       归还次数=267,   比例=0.09973851326111319
还到 B 店：租出次数=2677,       归还次数=813,   比例=0.3036981695928278
还到 C 店：租出次数=2677,       归还次数=0,     比例=0.0
还到 D 店：租出次数=2677,       归还次数=1597,  比例=0.596563317146059
从 B 店租出：
还到 A 店：租出次数=3013,       归还次数=2412,  比例=0.8005310321938267
还到 B 店：租出次数=3013,       归还次数=0,     比例=0.0
还到 C 店：租出次数=3013,       归还次数=601,   比例=0.19946896780617324
还到 D 店：租出次数=3013,       归还次数=0,     比例=0.0
从 C 店租出：
还到 A 店：租出次数=1555,       归还次数=0,     比例=0.0
还到 B 店：租出次数=1555,       归还次数=1385,  比例=0.8906752411575563
还到 C 店：租出次数=1555,       归还次数=170,   比例=0.10932475884244373
还到 D 店：租出次数=1555,       归还次数=0,     比例=0.0
从 D 店租出：
还到 A 店：租出次数=2655,       归还次数=0,     比例=0.0
还到 B 店：租出次数=2655,       归还次数=811,   比例=0.3054613935969868
还到 C 店：租出次数=2655,       归还次数=780,   比例=0.2937853107344633
还到 D 店：租出次数=2655,       归还次数=1064,  比例=0.4007532956685499
```

同理可以统计出所有的转移概率（精确到小数点后面一位），以 A 店为例：

- 从A号店租车后
    - 还到A号店的概率是0.1
    - 还到B号店的概率是0.3
    - 还到C号店的概率是0.0
    - 还到D号店的概率是0.6

把上述数据绘制在图 1 中，避免赘述。

<center>
<img src="./img/Car1.png" width="500">

图 1 状态转移概率图
</center>

图 1 中的左图展示了从 A 店租车，到 A,B,D 店还车的情况，其中，$s=A$ 表示当天早晨租车，而 $s'=A$ 表示晚上还车（或者是第二天该车在哪里出现）；右图展示了综合情况。

### 3 解决经理的问题

重复一下需求：公司经理想知道如果有一天（命名为第 0 天）这辆车从 B 号店出租了，2 天后的早晨最有可能在哪个店出现？5 天后又会如何？

一般情况下，读者会根据图 1 从 B 店出发，再根据概率顺藤摸瓜地计算出第 1 天的情况，再计算出第 2 天的情况。

- 第 1 天早晨出现在各门店的概率是：$[0.8,\ 0.0,\ 0.2,\ 0.0]$。
- 第 2 天早晨出现在各门店的概率是......有点儿复杂，我们绘制出图 2 来帮助整理思路。

<center>
<img src="./img/Car2.png" width="600">

图 2 第一天和第二天的出现概率
</center>

从图2一眼就可以看出来，第 2 天早晨该车出现在各门店的概率就是两个连续的概率之乘积，比如：
- 第 1 天
    - 出现在A店（橙色）的概率是 0.8；
    - 出现在C店（红色）的概率是 0.2；
    - 但是不可能出现在B,D店；
    
- 第 2 天
    - 由于A店有0.3的概率还到B店，所以出现在B店的概率是$0.8 \times 0.3=0.24$；
    - 由于C店有0.9的概率还到B店，所以出现在B店的概率是$0.2 \times 0.9=0.18$；

所以，该车第3天早晨出现在B店的概率是 $0.24+0.18=0.42$。出现在其它店的数字也可以同理得到。

我们再把图 2 的所有情况列在表 1 中，便于统计，数字的颜色和图 2 是一一对应的，表示是哪个门店，方便读者对照理解。

表 1 第一天和第二天的概率计算统计表

|从$\rightarrow$到|A店|B店|C店|D店|第1天|
|:-:|-|-|-|-|-|
|**A店**|$\color{orange}{0.8\times0.1=0.08}$|$\color{orange}{0.8\times0.3=0.24}$|$\color{orange}{0.8\times0.0=0.00}$|$\color{orange}{0.8\times0.6=0.48}$|$\color{orange}{0.8}$|
|**B店**|$\color{green}{0.0\times0.8=0.0}$|$\color{green}{0.0\times0.0=0.0}$|$\color{green}{0.0\times0.2=0.0}$|$\color{green}{0.0\times0.0=0.0}$|$\color{green}{0.0}$|
|**C店**|$\color{red}{0.2\times0.0=0.00}$|$\color{red}{0.2\times0.9=0.18}$|$\color{red}{0.2\times0.1=0.02}$|$\color{red}{0.2\times0.0=0.00}$|$\color{red}{0.2}$|
|**D店**|$\color{blue}{0.0\times0.0=0.0}$|$\color{blue}{0.0\times0.3=0.0}$|$\color{blue}{0.0\times0.3=0.0}$|$\color{blue}{0.0\times0.4=0.0}$|$\color{blue}{0.0}$|
|**第2天**|$\color{orange}{0.08}$|$\color{green}{0.24+0.18=0.42}$|$\color{red}{0.02}$|$\color{blue}{0.48}$|$1.0$|

数据解读：

- 表 1 除去表头，中间部分的 4x4 区域，和图 2 的数据是一致的。
- 最后一列是中间 4 列的和，所以正好是第 1 天该车的出现概率。
- 最后一行是中间 4 行的和，所以是第 2 天该车的出现概率。

OK! 2 天后的问题解决了，那么 5 天后呢？这么计算太麻烦了，我们引入转移概率矩阵的概念来帮助解决问题。


### 4 转移概率矩阵

【代码位置：RentCar_4_Matrix.py】

**转移概率矩阵**，又称为**状态分布矩阵**，它用矩阵的形式定义了从任意事件（状态）转换到另一个事件（状态）的概率。

如何得到这个矩阵呢？

在代码 RentCar_2_OneByOne.py 中，虽然已经通过逐个计算从指定门店租出到指定门店还车的概率来得到该矩阵，但其实不用这么麻烦，利用 numpy 数组的一些特性，可以用更简单的代码一次搞定所有门店的数据：

```Python
def calculate_matrix(n_states, data_array):
    # 定义一个 n x n 的数组（矩阵）
    P_counter = np.zeros((n_states, n_states))
    rows = data_array.shape[1]  # 获得记录行数
    for i in range(rows):   # 一共100行记录
        data_list = data_array[i].ravel().tolist()
        # 把 ABCD 变成 0123
        X = [ord(x)-65 for x in data_list]
        for i in range(len(X)-1):
            rent_from = X[i]
            return_to = X[i+1]
            # 对应位置计数加 1
            P_counter[rent_from, return_to] += 1
    #endfor
    # 计算各列之和
    sum = np.sum(P_counter, axis=1, keepdims=True)
    print("各个状态出现的次数:\n",sum)
    P = P_counter / sum
    return P
```
运行代码 RentCar_4_Matrix.py，得到：
```
[Out]
各个状态出现的次数:
 [[2677.]
 [3013.]
 [1555.]
 [2655.]]
概率转移矩阵:
[[0.1 0.3 0.  0.6]
 [0.8 0.  0.2 0. ]
 [0.  0.9 0.1 0. ]
 [0.  0.3 0.3 0.4]]
```

这样就得到了一个矩阵：

$$
P = 
\begin{pmatrix}
P_{11} & P_{12} & P_{13} & P_{14}
\\
P_{21} & P_{22} & P_{23} & P_{24}
\\
P_{31} & P_{32} & P_{33} & P_{34}
\\
P_{41} & P_{42} & P_{43} & P_{44}
\end{pmatrix}= 
\begin{pmatrix}
0.1 & 0.3 & 0.0 & 0.6
\\
0.8 & 0.0 & 0.2 & 0.0
\\
0.0 & 0.9 & 0.1 & 0.0
\\
0.0 & 0.3 & 0.3 & 0.4
\end{pmatrix}
\tag{3}
$$

这就相当于把图 1 变成表 2，方便使用计算机来解决问题。

表 2 转移概率表

|P: 从$\rightarrow$到|A|B|C|D||转出总和|
|:-:|-|-|-|-|-|-|
|**A**|0.1|0.3|0.0|0.6||1.0|
|**B**|0.8|0.0|0.2|0.0||1.0|
|**C**|0.0|0.9|0.1|0.0||1.0|
|**D**|0.0|0.3|0.3|0.4||1.0|
||||||||
|转入总和|0.9|1.5|0.6|1.0||4.0|

数据解读：

- 是一个 $n \times n$ 的方阵（中间的 4x4 区域）。
- 矩阵各元素都是非负的，即：$0 \le P_{i,j} \le 1$。
- 各行元素（输出概率）之和为 1，即：$\sum^n_{j=1} P_{i,j}=1$。
- 对于输入概率总和没有限制，但是最终的总和（右下角）在行列上肯定应该一致，都是4.0（因为有个 4 个门店），即：$\sum_{i=1}^n \sum_{j=1}^n P_{i,j} = n$。


而对于一个通用的问题，矩阵形式是：

$$
P = 
\begin{pmatrix}
P_{11} & \cdots & P_{1n}
\\
\vdots & \ddots & \vdots
\\
P_{n1} & \cdots & P_{nn}
\end{pmatrix}
\tag{4}
$$

### 5 迭代计算

【代码位置：RentCar_5_OneByOne.py】

下面我们使用矩阵计算来代替复杂的循环逻辑：

1. 首先定义第 0 天的初始向量：
$$
X_0=(0,1,0,0) \tag{5}
$$

    表示豪华宝驴车目前肯定在 B 门店。

2. 该车第 1 天在哪个门店出现的问题可以转换为：

$$
X_1 = X_0 P=(0, 1 , 0 , 0)
\begin{pmatrix}
0.1 & 0.3 & 0.0 & 0.6
\\
0.8 & 0.0 & 0.2 & 0.0
\\
0.0 & 0.9 & 0.1 & 0.0
\\
0.0 & 0.3 & 0.3 & 0.4
\end{pmatrix}=
(0.8,\ 0.0,\ 0.2,\ 0.0)
\tag{6}
$$

3. 该车第 2 天在哪个门店出现的问题可以递归计算出：

$$
X_2 = X_1 P=(0.8,\ 0.0,\ 0.2,\ 0.0)
\begin{pmatrix}
0.1 & 0.3 & 0.0 & 0.6
\\
0.8 & 0.0 & 0.2 & 0.0
\\
0.0 & 0.9 & 0.1 & 0.0
\\
0.0 & 0.3 & 0.3 & 0.4
\end{pmatrix}=
(0.08, \ 0.42, \ 0.02, \ 0.48) \tag{7}
$$

式7的结果和表1完全一致。

推广到一般情况，计算第 $n+1$ 天的概率时，需要使用第 $n$ 天的结果

$$
X_{n+1}=X_n P \tag{8}
$$


我们可以很方便地写出代码，来计算第 5 天的出现概率：

```python
P = np.array([
    [0.1, 0.3, 0.0, 0.6],
    [0.8, 0.0, 0.2, 0.0],
    [0.0, 0.9, 0.1, 0.0],
    [0.0, 0.3, 0.3, 0.4]
])

def calculate_day(X, P, day):
    X_n = X.copy()
    for i in range(day+1): # 因为是从0开始，所以day要+1
        print(str.format("day {0}: {1} ", i, X_n))
        X_n = np.dot(X_n, P)

if __name__=="__main__":
    X = np.array([0,1,0,0]) # 该车第0天在B店
    calculate_day(X, P, 5)  # 计算第5天在哪里
```
运行代码 RentCar_5_OneByOne.py，得到：
```
[Out]
day 0: [0 1 0 0] 
day 1: [0.8 0.  0.2 0. ] 
day 2: [0.08 0.42 0.02 0.48]
day 3: [0.344 0.186 0.23  0.24 ]
day 4: [0.1832 0.3822 0.1322 0.3024]
day 5: [0.32408 0.26466 0.18038 0.23088]
```

OK！经理的问题彻底解决了，在第 5 天的时候，该豪华宝驴车在 4 个门店出现的概率依次是：

$[0.32408,\ 0.26466,\ 0.18038,\ 0.23088]$

可以再看一下第2天的数据（day 2），也与前面的手工计算结果一致。

### 6 K步转移概率矩阵

***代码位置：RentCar_6_KStep.py***

从上面的例子我们可以看到，只有一步的转移概率是不能满足实际需要的，通常需要迭代计算才能知道 K 步后的情况如何，虽然这已经比没有矩阵时的复杂循环逻辑好了很多。

比如，5 步后的概率应该是：

$$
X_5 = X_4 P=(X_3P)P=((X_2P)P)P=(((X_1P)P)P)P=((((X_0P)P)P)P)P=X_0 P^5 \tag{9}
$$

式 4 可以定义为一步转移概率矩阵，那么从式 9 的推导可以得到式 10，定义为 K 步转移概率： 

$$
P^K = 
\begin{pmatrix}
P_{11} & \cdots & P_{1n}
\\
\vdots & \ddots & \vdots
\\
P_{n1} & \cdots & P_{nn}
\end{pmatrix}^K
\tag{10}
$$

代码如下

```Python
# 计算K步转移概率矩阵        
def K_step_matrix(P, K):
    Pk=P.copy()
    for i in range(K-1):
        Pk=np.dot(Pk,P)
    return Pk
```
读者可能会注意到循环次数是 K-1，而不是 K。假设我们计算 K=2 步转移矩阵，那么一步矩阵P和自己做 1 次矩阵相乘就可以了，而不是做 2 次。所以 K 步矩阵只需要做 K-1 次矩阵相乘。另外一个细节是 np.dot(P,Pk) 和 np.dot(Pk,P) 都会得到相同的结果，读者可以自行验证。

得到 K 步转移矩阵后，可以用如下代码简单地直接计算第 5 天的情况：

```Python
if __name__=="__main__":
    X = np.array([0,1,0,0])
    P5 = K_step_matrix(P, 5)
    print(P5)
    X5 = np.dot(X, P5)
    print(X5)
```
```
[Out]
5步转移概率矩阵:
 [[0.25585 0.31989 0.14028 0.28398]
 [0.32408 0.26466 0.18038 0.23088]
 [0.19728 0.36459 0.14005 0.29808]
 [0.26448 0.29469 0.15843 0.2824 ]]
第 5 天的情况： [0.32408 0.26466 0.18038 0.23088]
```

与上面的迭代方法计算结果一致。

观察打印输出中得到的 5 步转移概率矩阵的数值，和是式 3 一样：
- 仍然是 4x4，表示 4 种状态之间的转移。
- 每行数字相加为 1，表示移出概率。

那么可以定义 k 步转移概率的公式为：

$$
P_{i,j}(t,t+k)=\Pr\{X_{t+k}=a_j|X_t = a_i\} \tag{11}
$$

$$
\sum_{j=1}^n P_{i,j}(t,t+k)=1, \ i=1,2,...,n \tag{12}
$$

其中，$n$ 为状态数量，$i,j$ 为行列序号，$a$ 为状态。

当转移概率$P_{i,j}(t,t + k)$只与 $i,j$ 及时间间距 $k$ 有关时，称转移概率具有平稳性。同时也称马尔可夫链是齐次的或时齐的。

### 7 更多步的情况

【代码位置：RentCar_7_Convergence.py】

从 K 步可以向更远的地方思考，如果 K 为无穷大时，这个转移概率矩阵是什么情况呢？

同样可以用代码做一个试验：

```Python
def Check_Convergence(P):
    P_curr = P.copy()
    for i in range(100000):
        P_next=np.dot(P,P_curr)
        print("迭代次数 =",i+1)
        print(P_next)
        if np.allclose(P_curr, P_next):
            break
        P_curr = P_next
    return P_next

if __name__=="__main__":
    Pn = Check_Convergence(P)
```
注意，在代码中使用了 np.allclose(P_curr, P_next) 来判断上一次迭代结果和本次迭代结果的差值，如果小于1e-6则认为已经收敛，停止循环。运行过程如下所示：
```
[Out]
迭代次数 = 1
[[0.25 0.21 0.24 0.3 ]
 [0.08 0.42 0.02 0.48]
 [0.72 0.09 0.19 0.  ]
 [0.24 0.39 0.21 0.16]]
迭代次数 = 2
[[0.193 0.381 0.156 0.27 ]
 [0.344 0.186 0.23  0.24 ]
 [0.144 0.387 0.037 0.432]
 [0.336 0.309 0.147 0.208]]

......

迭代次数 = 27
[[0.26966338 0.30337037 0.1573036  0.26966265]
 [0.26966195 0.30337167 0.15730289 0.26966349]
 [0.26966412 0.3033697  0.15730396 0.26966222]
 [0.26966285 0.30337085 0.15730334 0.26966296]]
迭代次数 = 28
[[0.26966264 0.30337105 0.15730323 0.26966309]
 [0.26966353 0.30337024 0.15730367 0.26966257]
 [0.26966217 0.30337147 0.157303   0.26966336]
 [0.26966296 0.30337075 0.15730339 0.2696629 ]]
```

一个有趣的现象是，当迭代了28次后就已经**收敛**到很小的误差了。可以认为在经过多次的 “租、还、租、还” 循环后，某辆车在四个门店的出现概率（精确到两位小数）固定为：$[0.27,\ 0.30,\ 0.16,\ 0.27]$。这种收敛并非本问题的特例，而是一种普遍的现象。

从实际情况来看：
- 可能是因为通州区太远了，所以顾客都偏好就近还车。
- 海淀区和朝阳区的停车场要大一些，以便可以停更多的车。
- 丰台区属于地广人稀的地段，去那里还车的大概都是去机场的顾客。
- 在经过统计各个门店的租出车辆数据后，需要定期地在门店之间转移车辆。


我们还可以比较一下表 2 的最后一行数据与$P^k$矩阵的数值，放在表 3 中。

表 3 初始概率与终极概率的比较

||A店|B店|C店|D店|
|-|-|-|-|-|-|
|$P^1$转入总和|0.9|1.5|0.6|1.0|4.0|
|$P^k$转移概率|0.27|0.30|0.16|0.27|

直观上看：
- B 店的初始转入总和为 1.5，最大，所以 $P^k$ 的值也最大，为 0.3；
- A 店与 D 店相差不多；
- C 店的初始转入概率总和值最小，最后的平稳概率值也最小。
