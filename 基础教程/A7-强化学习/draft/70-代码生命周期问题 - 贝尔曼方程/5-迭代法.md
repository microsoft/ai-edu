
### 迭代法



- 用手工列方程组的办法肯定可以得到解，但是当状态数量到几十个时，虽然都是一次线性方程组，手工计算了已经变得很大，非常容易出错。

- 矩阵法虽然可以得到数学解析解，但是，计算逆矩阵时非常耗时，时间复杂度为 $O(n^3)$，$n$ 是状态的数量。当状态数量增加到千级、万级时，时间开销将变得不可接受。

### 原始迭代法

下面我们尝试一下计算机最擅长的迭代方式。

根据式

$$
V(s) = R(s)+ \gamma \sum_{s'} P_{ss'}V(s')
\tag{1}
$$

可以给一个初始值，即各个状态的奖励值：

$$
\begin{cases}
v_0=-3
\\
v_1=0
\\
v_2=1
\\
v_3=3
\\
v_4=2
\\
v_5=-1
\\
v_6=0
\end{cases}
\tag{2}
$$

根据式 1 可以写出方程组，并带入式 2 定义的初始值：

$$
\begin{cases}
v_0=-3+0.7v_0+0.3v_1 =(-3)+0.7\cdot(-3)+0.3\cdot0=-5.1
\\
v_1=0+0.6v_0+0.4v_2 =0+0.6\cdot(-3)+0.4\cdot1=-1.4
\\
v_2=1+0.9v_3+0.1v_6=1+0.9\cdot3+0.1\cdot0=3.7
\\
v_3=3+0.2v_4+0.8v_5=3+0.2\cdot2+0.8\cdot(-1)=2.6
\\
v_4=2+0.2v_1+0.5v_2+0.3v_3=2+0.2\cdot0+0.5\cdot1+0.3\cdot3=3.4
\\
v_5=-1+v_6=-1+0=-1
\\
v_6=0
\end{cases}
\tag{3}
$$

把式 3 的结果带入式 1 再做一次迭代：

$$
\begin{cases}
v_0=-3+0.7\cdot(-5.1)+0.3\cdot(-1.4) =-6.99
\\
v_1=0+0.6\cdot(-5.1)+0.4\cdot3.7=-1.58
\\
v_2=1+0.9\cdot2.6+0.1\cdot0=3.34
\\
v_3=3+0.2\cdot3.4+0.8\cdot(-1)=2.88
\\
v_4=2+0.2\cdot(-1.4)+0.5\cdot3.7+0.3\cdot2.6=4.35
\\
v_5=-1
\\
v_6=0
\end{cases}
\tag{4}
$$

```Python
# 原始迭代法
def raw_iteration(dataModel, gamma):
    V = dataModel.R
    V_next = V.copy()
    count = 0
    while (count < 1000):   # 1000 是随意指定的一个比较大的数，避免不收敛而导致while无限
        count += 1
        V_next[0] = dataModel.R[0] + gamma*(0.7 * V[0] + 0.3 * V[1])
        V_next[1] = dataModel.R[1] + gamma*(0.6 * V[0] + 0.4 * V[2])
        V_next[2] = dataModel.R[2] + gamma*(0.9 * V[3] + 0.1 * V[6])
        V_next[3] = dataModel.R[3] + gamma*(0.2 * V[4] + 0.8 * V[5])
        V_next[4] = dataModel.R[4] + gamma*(0.2 * V[1] + 0.5 * V[2] + 0.3 * V[3])
        V_next[5] = dataModel.R[5] + gamma*V[6]
        V_next[6] = dataModel.R[6]
        if np.allclose(V_next, V):
            break
        V = V_next.copy()
        if (count < 3):
            print(V)
    print("迭代次数 :", count)
    return V
```
```
迭代次数 : 97
Bug:    -21.633
Coding: -11.633
Test:   3.366
Review: 2.629
Refactor:       2.145
Merge:  -1.0
End:    0.0
```

### 矩阵迭代法

更一般地，求解线性方程组有一套成熟的做法

算法

---

定义迭代式：$x=Ax+B$
给定任意初始值$x^{(0)}$，一般设置为 0
迭代求解 $x^{(k)}=Ax^{(k-1)}+B$
得到：$x^{(0)},x^{(1)},\cdots,x^{(k)}$，直到序列收敛于某个值

---

```Python
# 矩阵迭代法
def matrix_iteration(dataModel, gamma):
    V = dataModel.R
    V_next = V.copy()
    count = 0
    while (count < 1000):   # 1000 是随意指定的一个比较大的数，避免不收敛而导致while无限
        count += 1
        V = dataModel.R + gamma * np.dot(dataModel.P, V_next)
        if np.allclose(V_next, V):
            break
        V_next = V.copy()
    print("迭代次数 :", count)
    return V
```

其结果与 raw_iteration() 方法完全一致

收敛定理

https://zhuanlan.zhihu.com/p/388744513


### 双数组迭代

算法

---

定义误差 $error$
任意初始化 $V(s)$，其中 $V(s_{End})=0$
$V_{next}(s) \leftarrow V(s)$
循环：
　　对每一个 $s \in S$：
　　　　$V_{next}(s) \leftarrow R_{ss'}+\gamma \sum P_{ss'}V(s')$
　　检查收敛性 $|V - V_{next}| < error$
　　如收敛则退出循环，否则 $V(s) \leftarrow V_{next}(s)$

---


```Python
# 贝尔曼方程迭代
def Bellman_Iteration_DoubleArray(dataModel, gamma):
    V_curr = np.zeros(dataModel.N)
    V_next = np.zeros(dataModel.N)
    count = 0
    while (count < 1000):   # 1000 是随意指定的一个比较大的数，避免不收敛而导致while无限
        # 遍历每一个 state 作为 start_state
        for curr_state in dataModel.S:
            # 得到转移概率
            next_states_probs = dataModel.P[curr_state.value]
            v_sum = 0
            # 计算下一个状态的 转移概率x状态值 的 和 v
            for next_state_value, next_state_prob in enumerate(next_states_probs):
                # if (prob[next_state] > 0.0):
                v_sum += next_state_prob * V_next[next_state_value]
            # end for
            V_curr[curr_state.value] = dataModel.R[curr_state.value] + gamma * v_sum
        # end for
        # 检查收敛性
        if np.allclose(V_next, V_curr):
            break
        # 把 V_curr 赋值给 V_next
        V_next = V_curr.copy()
        count += 1
    # end while
    print("迭代次数 :", count)
    return V_next
```



### 单数组就地更新

```Python
# 单数组就地更新
def Bellman_Iteration_SingleArray(dataModel, gamma):
    V = np.zeros(dataModel.N)
    V_old = V.copy()
    count = 0
    while (count < 1000):   # 1000 是随意指定的一个比较大的数，避免不收敛而导致while无限
        # 遍历每一个 state 作为 start_state
        for curr_state in dataModel.S:
            # 得到转移概率
            next_states_probs = dataModel.P[curr_state.value]
            v_sum = 0
            # 计算下一个状态的 转移概率x状态值 的 和 v
            for next_state_value, next_state_prob in enumerate(next_states_probs):
                # if (prob[next_state] > 0.0):
                v_sum += next_state_prob * V[next_state_value]
            # end for
            V[curr_state.value] = dataModel.R[curr_state.value] + gamma * v_sum
        # end for
        # 检查收敛性
        if np.allclose(V, V_old):
            break
        # 把 V_curr 赋值给 V_next
        V_old = V.copy()
        count += 1
    # end while
    print("迭代次数 :", count)
    return V
```

运行结果

```
迭代次数 : 80
[-21.63293714 -11.63330975   3.36612696   2.62902565   2.14510923
  -1.           0.        ]
Bug:    -21.633
Coding: -11.633
Test:   3.366
Review: 2.629
Refactor:       2.145
Merge:  -1.0
End:    0.0
```

可以发现，单数组就地更新的迭代收敛次数只需要 80 次，而双数组需要 97 次。
