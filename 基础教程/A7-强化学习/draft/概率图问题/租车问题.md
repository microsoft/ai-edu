

## 租车问题

### 1 提出问题

在北京有一个叫做“四通八达”的租车连锁公司，分别在海淀区、朝阳区、通州区、丰台区开设了 4 个门店，编号分别为 A,B,C,D。客户可以从任意一个店租车，用完后可以归还到任意一个店。为了简化问题，我们假设客户都是早晨租车开走，晚上归还。

为了招徕顾客，公司特地买了一辆高档宝驴车，以普通价格出租。公司经理想知道如果有一天这辆车从B号店出租了，2 天后的早晨会最有可能在哪个店出现？9 天后又会如何？

公司统计了去年全年的租车、还车记录，抽样以后发现车辆在四个店的流动情况是这样的：

```
["B", "A", "A", "D", "D", "C", "B", "A",......]
```

数据顺序的含义是，有一辆车：

- 第一天从B店被租走，晚上还到A店；
- 第二天从A店被租走，晚上还到A店；
- 第三天从A店被租走，晚上还到D店；
- 第四天从D店被租走，晚上还到D店；
- 第五天从D店被租走，晚上还到C店；
- ......

列表中一共是10000条记录，可以认为是100辆车在100天内的借还地点数据的集合。这其中有什么规律呢？

其实这是一个标准的转移概率的问题。

### 2 转移概率
　　
转移概率是马尔可夫链中的重要概念，若马氏链分为 m 个状态组成，统计历史数据会是由这 m 个状态所组成的序列。从任意一个状态出发，经过任意一次转移，必然出现状态1,2,……,m 中的一个，这种状态之间的转移称为转移概率。

在本问题中，有 4 个门店，所以一共就有 4 个状态。

如何根据历史数据计算出转移概率呢？其实就是条件概率：
$$
P(A|B)=\frac{P(A,B)}{P(B)} \tag{1}
$$

具体到本问题中，公式如下：

$$
P_{i,j}=\Pr\{X_{t+1}=a_j|X_t = a_i\}=\frac{\Pr\{X_{t+1}=a_j,X_t=a_i\}}{\Pr\{X_t=a_i\}}  \tag{2}
$$

公式 2 的含义是，在某一时刻 $t$，处于 $a_i$ 状态时，下一个时刻 $t+1$ 时，转移到 $a_j$ 状态的概率。

比较公式 2 和 1，形式上是完全相同的，只是里面的变量更具体化一些。

用上面的具体数据举例说明，如果我们想统计从 A 店借车，在 B 店还车的概率，应该这样做：

1. 设置两个计数器，一个 $nA = 0$，一个是 $nB = 0$；
1. 先找到所有的 A，出现一次就记录 $nA = nA+1$，假设一共出现 1000 次；
2. 再找到紧接着 A 的是不是 B，如果是，则计数器 $nB=nB+1$，假设一共 110 次；
3. 所有数据都统计完后计算：$P_{AB} = \frac{nB}{nA}=\frac{110}{1000}=0.11$

```Python
# 计算从a_i转移到a_j的概率
def calculate_P(X, a_i, a_j):
    n_i = 0
    n_j = 0
    for x in range(len(X)-1):
        if a_i == X[x]:
            n_i += 1
            if a_j == X[x+1]:
                n_j += 1
    print(n_i, n_j, n_j/n_i)
#end def
calculate_P(X, 0, 1)    # 0代表A店, 1代表B店

[Out]
2703 819 0.3029966703662597
```
上述代码统计出 A 店一共出现 2703 次，紧接在 A 后的 B 出现 819 次，所以 $P_{AB}=\frac{819}{2703}\approx 0.3$。

同理可以统计出所有的转移概率，以 A 店为例：

- 从A号店租车后
    - 还到A号店的概率是0.1
    - 还到B号店的概率是0.3
    - 还到C号店的概率是0.0
    - 还到D号店的概率是0.6

当然，也统计了从 B,C,D 店租车还车的记录，绘制在图 1 中，避免赘述。

<img src="./img/Car1.png" width="500">

图 1

### 3 解决经理的问题

公司经理想知道如果有一天（命名为第 0 天）这辆车从 B 号店出租了，2 天后的早晨会最有可能在哪个店出现？10 天后又会如何？

一般情况下，读者会根据图 1 从 B 店出发，根据概率顺藤摸瓜地计算出第 1 天的情况，再计算出第 2 天的情况。

- 第 1 天早晨出现在各门店的概率是：0.8, 0.0, 0.2, 0.0。
- 第 2 天早晨出现在各门店的概率是......有点儿复杂，我们绘制出图 2 来帮助整理思路。

<img src="./img/Car2.png" width="600">

图 2

从图2一眼就可以看出来，第 2 天早晨该车出现在各门店的概率就是两个连续的概率之乘积，比如：
- 第 1 天
    - 出现在A店（橙色）的概率是 0.8；
    - 出现在C店（红色）的概率是 0.2；
    - 但是不可能出现在B,D店；
    
- 第 2 天
    - 由于A店有0.3的概率还到B店，所以出现在B店的概率是$0.8 \times 0.3=0.24$；
    - 由于C店有0.9的概率还到B店，所以出现在B店的概率是$0.2 \times 0.9=0.18$；

所以，该车第3天早晨出现在B号店的概率是 $0.24+0.18=0.42$。出现在其它店的数字也可以同理得到。

其它店的所有情况列在表 1 中，便于统计。

表1

|从$\rightarrow$到|A门店|B门店|C门店|D门店|第1天|
|:-:|-|-|-|-|-|
|A号门店|$0.8\times0.1=0.08$|$0.8\times0.3=0.24$|$0.8\times0.0=0.00$|$0.8\times0.6=0.48$|$0.8$|
|B号门店|$0.0\times0.8=0.0$|$0.0\times0.0=0.0$|$0.0\times0.2=0.0$|$0.0\times0.0=0.0$|$0.0$|
|C号门店|$0.2\times0.0=0.00$|$0.2\times0.9=0.18$|$0.2\times0.1=0.02$|$0.2\times0.0=0.00$|$0.2$|
|D号门店|$0.0\times0.0=0.0$|$0.0\times0.3=0.0$|$0.0\times0.3=0.0$|$0.0\times0.4=0.0$|$0.0$|
|第2天|$0.08$|$0.24+0.18=0.42$|$0.02$|$0.48$|$1.0$|

数据解读：

- 表 1 除去表头，中间部分的 4x4 区域，和图2的数据是一致的。
- 最后一列是中间4列的和，所以正好是第2天的出现概率。
- 最后一行是中间4行的和，所以是第3天的出现概率。

OK! 2 天后的问题解决了，那么 9 天后呢？这么计算太麻烦了，我们引入转移概率矩阵的概念来帮助解决问题。


### 4 转移概率矩阵

把图1变成表2，方便使用计算机来解决问题。如果从原始数据计算的画，可以用更简单的代码一次搞定，不需要一个个地计算：

```Python
def calculate_Matrix(n_states, X):
    P_counter = np.zeros((n_states, n_states))
    for i in range(len(X)-1):
        a_i = X[i]
        a_j = X[i+1]
        P_counter[a_i, a_j] += 1
    #endfor
    # 计算各列之和
    sum = np.sum(P_counter, axis=1, keepdims=True)
    print("各个状态出现的次数:\n",sum)
    P = P_counter / sum
    return P
#enddef

# 把 ABCD 变成 0123
X = [ord(x)-65 for x in data_list]
# 计算转移矩阵
P = calculate_Matrix(n_states, X)
print("概率转移矩阵:")
print(np.around(P, 1))

[Out]
各个状态出现的次数:
 [[2703.]
 [3040.]
 [1568.]
 [2689.]]
概率转移矩阵:
[[0.1 0.3 0.  0.6]
 [0.8 0.  0.2 0. ]
 [0.  0.9 0.1 0. ]
 [0.  0.3 0.3 0.4]]
```

表2

|P: 从$\rightarrow$到|A|B|C|D|输出总和|
|:-:|-|-|-|-|-|
|A|0.1|0.3|0.0|0.6|1.0|
|B|0.8|0.0|0.2|0.0|1.0|
|C|0.0|0.9|0.1|0.0|1.0|
|D|0.0|0.3|0.3|0.4|1.0|
|输入总和|0.9|1.5|0.6|1.0|4.0|

- 是一个 $n \times n$ 的方阵（中间的 4x4 区域）。
- 矩阵各元素都是非负的，即：$0 \le P_{i,j} \le 1$。
- 各行元素（输出概率）之和为 1，即：$\sum^n_{j=1} P_{i,j}=1$。
- 对于输入概率总和没有限制，但是最终的总和（右下角）在行列上肯定应该一致，都是4.0（因为有个 4 个门店），即：$\sum_{i=1}^n \sum_{j=1}^n P_{i,j} = n$。

用矩阵来表示

$$
P = 
\begin{pmatrix}
P_{11} & P_{12} & P_{13} & P_{14}
\\
P_{21} & P_{22} & P_{23} & P_{24}
\\
P_{31} & P_{32} & P_{33} & P_{34}
\\
P_{41} & P_{42} & P_{43} & P_{44}
\end{pmatrix}= 
\begin{pmatrix}
0.1 & 0.3 & 0.0 & 0.6
\\
0.8 & 0.0 & 0.2 & 0.0
\\
0.0 & 0.9 & 0.1 & 0.0
\\
0.0 & 0.3 & 0.3 & 0.4
\end{pmatrix}
\tag{3}
$$

而对于一个通用的问题，矩阵形式是：

$$
P = 
\begin{pmatrix}
P_{11} & \cdots & P_{1n}
\\
\vdots & \ddots & \vdots
\\
P_{n1} & \cdots & P_{nn}
\end{pmatrix}
\tag{4}
$$

有了矩阵，我们可以方便地使用矩阵运算来代替复杂的循环逻辑

首先定义初始向量 
$$
X_0=(0,1,0,0) \tag{5}
$$

表示豪华宝驴车在 B 门店

那么第2天在哪个门店的问题可以转换为 

$$
X_1 = X_0 P=(0, 1 , 0 , 0)
\begin{pmatrix}
0.1 & 0.3 & 0.0 & 0.6
\\
0.8 & 0.0 & 0.2 & 0.0
\\
0.0 & 0.9 & 0.1 & 0.0
\\
0.0 & 0.3 & 0.3 & 0.4
\end{pmatrix}=
(0.8,\ 0.0,\ 0.2,\ 0.0)
\tag{6}
$$

那么第3天在哪个门店的问题可以递归计算出 
$$
X_2 = X_1 P=(0.08, \ 0.43, \ 0.02, \ 0.48) \tag{7}
$$

式7的结果和表1完全一致。

推广到一般情况，计算第 $n+1$ 天的概率时，需要使用第 $n$ 天的结果

$$
X_{n+1}=X_n P \tag{8}
$$


我们可以很方便地写出代码

```Python
P = np.array([
    [0.1, 0.3, 0.0, 0.6],
    [0.8, 0.0, 0.2, 0.0],
    [0.0, 0.9, 0.1, 0.0],
    [0.0, 0.3, 0.3, 0.4]
])

def calculate_day(P, day):
    X = np.array([0,1,0,0])
    X_curr = X.copy()
    for i in range(day):
        print(str.format("day {0}: {1} ", i+1, X_curr))
        X_next = np.dot(X_curr, P)
        X_curr = X_next
#enddef

calculate_day(P, 10)    # 10表示计算10天的数据

[Out]
day 0: [0 1 0 0] 
day 1: [0.8 0.  0.2 0. ] 
day 2: [0.08 0.42 0.02 0.48]
day 3: [0.344 0.186 0.23  0.24 ]
day 4: [0.1832 0.3822 0.1322 0.3024]
day 5: [0.32408 0.26466 0.18038 0.23088]
day 6: [0.244136 0.32883  0.140234 0.2868  ]
day 7: [0.2874776 0.2854914 0.1658294 0.2612016]
day 8: [0.25714088 0.31385022 0.1520417  0.2769672 ]
day 9: [0.27679426 0.29706995 0.16106437 0.26507141]
```

OK！经理的问题解决了，在第 9 天的时候，该豪华宝驴车在 4 个门店出现的概率依次是：

$[0.27679426,\ 0.29706995,\ 0.16106437,\ 0.26507141]$

### 5 n-步转移概率矩阵
### 收敛