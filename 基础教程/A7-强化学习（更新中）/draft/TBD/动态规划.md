@@ -1,152 +0,0 @@

### 动态规划（迭代法）

**Those who cannot remember the past are condemned to repeat it.**

**那些不记得过去的人注定要重蹈覆辙。** 这是动态规划的经典名句。下面我们先回忆一下动态规划的基本思想。

动态规划（Dynamic Programming，简称DP）动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。

动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。 通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量： 一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。 这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。虽然抽象后进行求解的思路并不复杂，但具体的形式千差万别，找出问题的子结构以及通过子结构重新构造最优解的过程很难统一，为了解决动态规划问题，只能靠多练习、多思考了。

### 问题一

妈妈问：“$1+2+3+4=?$”
弟弟（一年级小学生，花了30秒在纸上验算加法然后）答：“等于10。”
爸爸问：“很好！那么 $7+4+3+2+1=?$”
姐姐（五年级小学生花了2秒思考然后立刻）答：“等于17。”
弟弟把刚拿起来的铅笔放下，无限崇拜地看着姐姐：“你是怎么这么快算出来的？”
姐姐说：“在你的答案上直接加 7 就行了。”
爸爸说：“不错，已经知道**利用历史经验**了！”

### 问题二

有一个 6 级的台阶，姐姐和弟弟每天放学回家都要经过。弟弟有时候一级一级地上台阶，有时候跳两级，有时候一级两级随意上跳，但是方法每天都不一样，姐姐在旁边帮他记录，保证他不重复。问：弟弟一共需要多少天可以遍历所有跳法？这次需要输出所有数列（1级时输出1，2级时输出2，3级时输出3，4级时输出5......）。

其实这是一个斐波那契数列的变形题目，可以抽象为：

$$
f(n)=f(n-1)+f(n-2), \qquad \qquad (f(1)=1, f(2)=2)
$$

其解题思路在于把问题逐级分解：

- 想跳到第 6 级台阶，先要跳到第 5 级或第 4 级台阶；
  又分成两种情况：
  - 想跳到第 5 级台阶，先要跳到第 4 级或第 3 级台阶；
    双分成两种情况：
    - 想跳到第 4 级台阶，先要跳到第 3 级或第 2 级台阶；
      叒分成两种情况：
      - 想跳到第3级台阶，先要跳到第 2 级或第 1 级台阶；
      - 想跳到第2级台阶，先要跳到第 1 级台阶。
            ......
  - 想跳到第 4 级台阶，先要跳到第 3 级或第 2 级台阶；
        ......

所以有：

$$
\begin{aligned}
f(6)&=f(5)+f(4) & {\footnotesize (到第 6 级台阶的方法有 5 \to 6 和 4 \to 6 两种组合)}
\\
f(5)&=f(4)+f(3)
\\
f(3)&=f(2)+f(1)
\\
f(2)&=2 & {\footnotesize (两级台阶有2种跳法)}
\\
f(1)&=1 & {\footnotesize (一级台阶只有1种跳法)}
\end{aligned}
$$

下面用三种方法来解决这个问题：
- 递归法
- 迭代法
- 备忘录法

【代码位置：】

```python
# 递归法
def f1(n):
    if n==1 or n==2:
        return n
    else:
        fn = f1(n-1) + f1(n-2)  # 递归调用函数本身两次
        return fn

# 迭代法
def f2(n):
    fn_2 , fn_1 = 1, 2
    for i in range(n-2):
        fn = fn_2 + fn_1    # 计算
        fn_2 = fn_1         # 迭代更换上一次的数值便于下次计算
        fn_1 = fn
    return fn

# 备忘录法
def f3(n):
    results = {1:1, 2:2}    # 当n=1和n=2时的结果是1和2
    for i in range(3, n+1):
        fi = results[i-1] + results[i-2]    # 从字典中直接取出结果
        results[i] = fi     # 在字典中添加n=i时的结果,i=3,4,5...
    return results
```
输出结果：
```
递归法结果 = 13
递归法耗时 = 0.0
迭代法结果 =  13
迭代法耗时 = 0.0009682178497314453
备忘录法结果 = {1: 1, 2: 2, 3: 3, 4: 5, 5: 8, 6: 13}
备忘录法耗时 = 0.001001119613647461
```
所以 6 级台阶一共有 13 种跳法。其中，备忘录法可以记录所有的计算结果，当然需要耗费 $O(n)$ 空间。

如果台阶数增加到 40，当计算 $f(40)$ 时，递归法需要花费成指数级增加的时间，在笔者的电脑上约17秒，复杂度为 $O(2^n)$。而迭代法和备忘录法仍然是瞬时完成，复杂度 $O(n)$。

```
递归法结果 = 165580141
递归法耗时 = 16.985862016677856
迭代法结果 =  165580141
迭代法耗时 = 0.0010018348693847656
备忘录法结果 = {1: 1, 2: 2, 3: 3, 4: 5, ......, 38: 63245986, 39: 102334155, 40: 165580141}
备忘录法耗时 = 0.0010018348693847656
```

**递归是朴素的思想，迭代是有效的方法**，两者都要掌握。


### 总结

动态规划问题满足三大重要性质：

- 最优子结构性质
  
  如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。

- 子问题重叠性质
  
  在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中（称作 DP 表格），当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率。

- 无后效性

  将各阶段按照一定的次序排列好之后，对于某个给定的阶段状态，它以前各阶段的状态无法直接影响它未来的决策，而只能通过当前的这个状态。换句话说，每个状态都是过去历史的一个完整总结。这就是无后向性，又称为无后效性。

动态规划最核心的思想，就在于拆分子问题，记住过往，减少重复计算。所以，**动态规划**，简单地说就是**记住求过解来节省后续的计算时间**。


在动态规划问题的解题思路中，重点是**定义 DP 表格的含义 + 状态转移方程**，已经有很多相关文献记载，请读者自行学习。在稍后要学习的贝尔曼方程

在本书中不再赘述




### 参考资料

https://cloud.tencent.com/developer/article/1817113

https://zhuanlan.zhihu.com/p/70689256

https://blog.csdn.net/weixin_41082481/article/details/115922389